////////////////////////////////////////////////////////////////////////
//
// XercesString.h
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef XERCESSTRING_H_INCLUDED
#define XERCESSTRING_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000


#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/framework/MemBufInputSource.hpp>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xercesc/framework/MemBufFormatTarget.hpp>

#if defined(UNICODE) || defined(_UNICODE)
// actually should be if sizeof(XmlCh) == sizeof(char_type), but PP cannot determine
class XercesStringTemp
{
	const char_type* p;
public:
	XercesStringTemp(const string_type& str) : p(str.c_str()) {}
	XercesStringTemp(const char_type* str) : p(str ? str : L"") {}

	operator const XMLCh*() const { return p; }
};


class XercesUnstringTemp
{
	const char_type* p;
public:
	XercesUnstringTemp(const XMLCh* str) : p(str ? str : L"") {}

	operator const char_type*() const { return p; }
};

#else

class XercesStringTemp
{
	XMLCh* p;
public:
	XercesStringTemp(const string_type& str) 
	{ 
		XMLCh* x = new XMLCh[str.size() + 1];
		p = x;
		for (string_type::const_iterator it = str.begin(); it != str.end(); ++it)
			*x++ = *it;
		*x = 0;
	}

	XercesStringTemp(const char_type* str) 
	{
		size_t len = str ? strlen(str) : 0;
		XMLCh* x = new XMLCh[len + 1];
		p = x;
		while(str && *str)
			*x++ = *str++;
		*x = 0;
	}

	~XercesStringTemp() { delete[] p; }

	operator const XMLCh*() const { return p; }
};


class XercesUnstringTemp
{
	char_type* p;
public:
	XercesUnstringTemp(const XMLCh* str) 
	{
		if (str == 0)
		{
			char_type * q = new char_type[1];
			*q = 0;
			p = q;
		}
		else
		{
			const XMLCh* end = str;
			while (*end) ++end;

			char_type* x = new char_type[end - str + 1];
			p = x;
			while (*str) *x++ = (char_type) *str++;
			*x = 0;
		}
	}	
	~XercesUnstringTemp()
	{
		delete[] p;
	}

	operator const char_type*() const { return p; }
};

#endif

#endif // XERCESSTRING_H_INCLUDED
