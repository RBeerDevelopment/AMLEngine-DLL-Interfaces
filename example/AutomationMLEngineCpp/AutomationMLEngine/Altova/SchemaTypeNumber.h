////////////////////////////////////////////////////////////////////////
//
// SchemaTypeNumber.h
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_SCHEMATYPENUMBER_H_INCLUDED
#define ALTOVA_SCHEMATYPENUMBER_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include "SchemaTypes.h"
#include <math.h>
#include <errno.h>

namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  Utility functions and templates
//
////////////////////////////////////////////////////////////////////////


namespace ICMapforceMachineUtil
{

template<typename TValue>
TValue InRangeInt(TValue nValue, __int64 nMin, __int64 nMax)
{
	if( nValue < nMin || nValue > nMax )
        ThrowOutOfRangeError();
	return nValue;
}


template<typename TValue>
TValue InRangeDbl(TValue nValue, const double nPosMin, const double nPosMax)
{
	TValue nTmpValue = nValue;
	if( nTmpValue == 0 )
		return nValue;
	if( nTmpValue < 0 )
		nTmpValue = -nTmpValue;
	if( nTmpValue >= nPosMin  &&  nTmpValue <= nPosMax )
		return nValue;
	ThrowOutOfRangeError();
}

} // end of namesapce ICMapforceMachineUtil


////////////////////////////////////////////////////////////////////////
//
//  CSchemaTypeNumber
//
////////////////////////////////////////////////////////////////////////

class ALTOVA_DECLSPECIFIER CSchemaTypeNumber
{
public:
	CSchemaTypeNumber() {};

	// architecture used is min. 32-bit so all smaller datatypes are omitted for calculation purposes
	// Note: unsigned datatypes have to be casted explicitly
	virtual long		ToLong() const = 0;		// 32 Bit integer
	virtual __int64		ToInt64() const = 0;	// 64 Bit integer
	virtual float		ToFloat() const = 0;	// 32 Bit floating-point
	virtual double		ToDouble() const = 0;	// 64 Bit floating-point

	virtual CSchemaType::ETypes NumericType() const = 0;
	static TCHAR* GetFormatString( CSchemaType::ETypes eType )
	{
		switch( eType )
		{
		case CSchemaType::k_byte:				return	(TCHAR*)_T("%hi");
        case CSchemaType::k_unsigned_byte:		return	(TCHAR*)_T("%hu");
        case CSchemaType::k_short:				return	(TCHAR*)_T("%hi");
        case CSchemaType::k_unsigned_short:		return	(TCHAR*)_T("%hu");
        case CSchemaType::k_int:				return	(TCHAR*)_T("%li");
        case CSchemaType::k_unsigned_int:		return	(TCHAR*)_T("%lu");
        case CSchemaType::k_long:				return	(TCHAR*)_T("%I64i");
        case CSchemaType::k_unsigned_long:		return	(TCHAR*)_T("%I64u");
        case CSchemaType::k_float:				return	(TCHAR*)_T("%G");
        case CSchemaType::k_double:				return	(TCHAR*)_T("%.15G");
        case CSchemaType::k_decimal:			return	(TCHAR*)_T("%lf");
		}
        return (TCHAR*)_T("");
	}

	static void TruncTrailingZeros( TCHAR* pszString, int nMinPrecision = 0 )
	{
		if( pszString == NULL )
			return ;

		TCHAR* pszComma = _tcschr( pszString, _T('.') );
		if( pszComma == NULL )
			return ;

		TCHAR* pszPos;

		for( pszPos = pszString + _tcslen( pszString ) - 1;
				pszPos > ( pszComma + nMinPrecision )  &&  *pszPos == _T('0');
				pszPos-- )
		{
			*pszPos = 0;
		}

		if( nMinPrecision == 0  &&  pszPos == pszComma )
			*pszPos = 0;
	}

};


//	calctype and ToCalcType() below are used for numerical operations with
//  CSchema... types (containing a value possible to be represented as number)
//  All numerical calculation functions access the value via ToCalcType().
//	Calculation-type is minimum 32 Bit (because we've 32 Bit processors) and
//	must be always signed (for unsigned use the next bigger type).

////////////////////////////////////////////////////////////////////////
//
//  template CSchemaNumber<..>
//
////////////////////////////////////////////////////////////////////////


template <CSchemaType::ETypes>
struct CSchemaNumberTraits
{
};

#define ALTOVA_DECLARE_SCHEMATYPETRAITS( typeCode, valueType, variantType, castVariantOver )\
	template <>\
	struct CSchemaNumberTraits< typeCode > {\
		typedef valueType TValue;\
	};

ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_byte, char, VT_I2, short );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_unsigned_byte, unsigned char, VT_UI1, unsigned char );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_short, short, VT_I2, short );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_unsigned_short, unsigned short, VT_I4, long );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_int, long, VT_I4, long );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_unsigned_int, unsigned long, VT_DECIMAL, double );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_long, __int64, VT_DECIMAL, double );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_unsigned_long, unsigned __int64, VT_DECIMAL, double );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_float, float, VT_R4, float );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_double, double, VT_R8, double );
ALTOVA_DECLARE_SCHEMATYPETRAITS( CSchemaType::k_decimal, double, VT_R8, double );




template <CSchemaType::ETypes eNumericType>
class CSchemaNumber : public CSchemaTypeNumber, public CSchemaType
{
public:
	typedef CSchemaNumberTraits< eNumericType > TTraits;
	typedef typename TTraits::TValue TValue;
	typedef typename TTraits::TValue TCalcValue;


	// Construction
	CSchemaNumber() : m_Value(0) {};
	CSchemaNumber( const TValue value ) : m_Value( value )								{ SetIsEmpty( false ); }
	CSchemaNumber( const TCHAR* szValue ) : m_Value( 0 )								{ Parse( szValue ); }
	CSchemaNumber( const tstring& sValue ) : m_Value( 0 )								{ Parse( sValue.c_str() ); }
	CSchemaNumber( const CSchemaType& rOther )											{ Assign( rOther ); }


	// Operators
	virtual operator									TValue() const					{ return IsEmpty() ? (TValue)0	: m_Value; }
	CSchemaNumber& operator	= (const TValue nValue)
	{
		SetIsEmpty( false );
		m_Value = nValue;
		return *this;
	}

	CSchemaNumber& operator	= (const CSchemaType& rOther)						{ return (CSchemaNumber&)Assign( rOther ); }

	TCalcValue											ToCalcValue() const				{ return ( TCalcValue )m_Value; }

	// ---------- Interface CSchemaType ----------
	// Operators
	virtual bool										ToBool() const
	{
		if( !CSchemaType::ToBool() )
			return (bool)0;
		return m_Value != 0;
	}

	virtual operator									tstring() const
	{
		if( IsEmpty() )
			return _T("");
		TCHAR szValue[32];
		_sntprintf(szValue, 32, GetFormatString(eNumericType), m_Value);
		return szValue;
	}


	// Operations
	virtual void										Empty()
	{
		CSchemaType::Empty();
		m_Value = 0;
	}

	virtual bool Parse( const TCHAR* sz )
	{
	tstring str = CSchemaType::normalize(CSchemaType::WHITESPACE_COLLAPSE, sz);
	const TCHAR* szValue = str.c_str();

		if( !CSchemaType::Parse( szValue ) )
			return false;
		InternalNumParse( szValue );
		return !IsEmpty();
	}

	virtual CSchemaType&								Assign( const CSchemaType& rOther )
	{
		if( CSchemaType::Assign( rOther ).IsEmpty() )
			return *this;

		const CSchemaTypeNumber* pNumberType = dynamic_cast<const CSchemaTypeNumber*>(&rOther);
		if( pNumberType == NULL )
			throw CAltovaException( CAltovaException::eError1, _T("") );
		switch( TYPE )
		{
		case CSchemaType::k_float:			m_Value = (TValue)pNumberType->ToFloat();	break;
		case CSchemaType::k_double:
		case CSchemaType::k_decimal:		m_Value = (TValue)pNumberType->ToDouble();	break;
		case CSchemaType::k_long:
		case CSchemaType::k_unsigned_long:	m_Value = (TValue)pNumberType->ToInt64();	break;
		default:
			m_Value = (TValue)pNumberType->ToLong();
		}

		return *this;
	}

	virtual CSchemaTypeNumber*							GetSchemaTypeNumberPtr() const				{ return (CSchemaTypeNumber*)this; }

	// ---------- Interface CSchemaTypeNumber ----------
	virtual ETypes										NumericType() const							{ return (CSchemaType::ETypes)TYPE; }
	virtual long										ToLong() const								{ return IsEmpty() ? (long)0	: ICMapforceMachineUtil::InRangeInt<long>((long)m_Value, LONG_MIN, LONG_MAX); }
	virtual __int64 									ToInt64() const								{ return IsEmpty() ? (__int64)0	: ICMapforceMachineUtil::InRangeInt<__int64>((__int64)m_Value, _I64_MIN, _I64_MAX); }
	virtual float										ToFloat() const								{ return IsEmpty() ? (float)0	: ICMapforceMachineUtil::InRangeDbl<float>((float)m_Value, 3.4E-38, 3.4E+38); }
	virtual double										ToDouble() const							{ return IsEmpty() ? (double)0	: ICMapforceMachineUtil::InRangeDbl<double>((double)m_Value, 1.7E-308, 1.7E+308); }

	enum { TYPE = eNumericType };
	typedef TValue										basetype;
	typedef TCalcValue									calctype;

protected:
	void												InternalNumParse( const TCHAR* szValue )	{ m_Value = _ttoi(szValue); }

	TValue												m_Value;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaByte
//	CSchemaUnsignedByte
//	CSchemaShort
//	CSchemaUnsignedShort
//	CSchemaInt
//	CSchemaUnsignedInt
//	CSchemaLong
//	CSchemaUnsignedLong
//	CSchemaFloat
//	CSchemaDouble
//	CSchemaDecimal
//
//	CSchemaInteger
//	CSchemaNegativeInteger
//	CSchemaPositiveInteger
//	CSchemaNonPositiveInteger
//
////////////////////////////////////////////////////////////////////////


typedef CSchemaNumber<CSchemaType::k_byte>	CSchemaByte;
typedef CSchemaNumber<CSchemaType::k_unsigned_byte>		CSchemaUnsignedByte;
typedef CSchemaNumber<CSchemaType::k_short>	CSchemaShort;
typedef CSchemaNumber<CSchemaType::k_unsigned_short>		CSchemaUnsignedShort;
typedef CSchemaNumber<CSchemaType::k_int>		CSchemaInt;
typedef CSchemaNumber<CSchemaType::k_unsigned_int>		CSchemaUnsignedInt;
typedef CSchemaNumber<CSchemaType::k_long>		CSchemaLong;
typedef CSchemaNumber<CSchemaType::k_unsigned_long>		CSchemaUnsignedLong;
typedef CSchemaNumber<CSchemaType::k_float>	CSchemaFloat;
typedef CSchemaNumber<CSchemaType::k_double>	CSchemaDouble;
typedef CSchemaNumber<CSchemaType::k_decimal>	CSchemaDecimal;

typedef CSchemaLong		CSchemaInteger;
typedef CSchemaInteger	CSchemaNegativeInteger;
typedef CSchemaInteger	CSchemaNonNegativeInteger;
typedef CSchemaInteger	CSchemaPositiveInteger;
typedef CSchemaInteger	CSchemaNonPositiveInteger;

//#define __SCHEMATYPENUMBER_IMPL_CODE__
#include "SchemaTypeNumber.impl"

////////////////////////////////////////////////////////////////////////
//
//  CSchemaBoolean
//
////////////////////////////////////////////////////////////////////////


class ALTOVA_DECLSPECIFIER CSchemaBoolean : public CSchemaTypeNumber, public CSchemaType
{
public:
	CSchemaBoolean() : m_Value( false )												{};
	CSchemaBoolean( const bool value) : m_Value( value != 0 )						{ SetIsEmpty( false ); };
	CSchemaBoolean( const TCHAR* szValue) : m_Value( false )						{ Parse(szValue); }
	CSchemaBoolean( const tstring& sValue) : m_Value( false )						{ Parse(sValue.c_str()); }
	CSchemaBoolean( const CSchemaType& rOther)										{ Assign( rOther ); }


	// Operators
	virtual operator								bool() const					{ return IsEmpty() ? false : m_Value; }
	long											ToCalcValue() const				{ return ToLong(); }
	virtual CSchemaBoolean& operator=(const bool bValue);
	virtual CSchemaBoolean& operator=(const CSchemaType& rOther)					{ return (CSchemaBoolean&)Assign(rOther); }

	// --------- Interface CSchemaType ----------
	// Operators
	virtual bool									ToBool() const;
	virtual operator								tstring() const;


	// Operations
	virtual void									Empty();
	virtual bool									Parse( const TCHAR* szValue );
	virtual CSchemaType&							Assign(const CSchemaType& rOther );

	virtual CSchemaTypeNumber*						GetSchemaTypeNumberPtr() const	{ return (CSchemaTypeNumber*)this; }

	// --------- Interface CSchemaTypeNumber ---------
	virtual ETypes									NumericType() const				{ return (CSchemaType::ETypes)TYPE; }
	virtual long									ToLong() const					{ return IsEmpty() ? (long)0	: m_Value; }
	virtual __int64									ToInt64() const					{ return IsEmpty() ? (__int64)0	: m_Value; }
	virtual float									ToFloat() const					{ return IsEmpty() ? (float)0.0	: m_Value; }
	virtual double									ToDouble() const				{ return IsEmpty() ? (double)0.0: m_Value; }

	enum { TYPE = CSchemaType::k_bool };
	typedef bool									basetype;
	typedef long									calctype;

protected:
	bool											m_Value;
};



} // namespace altova

#endif // ALTOVA_SCHEMATYPENUMBER_H_INCLUDED
