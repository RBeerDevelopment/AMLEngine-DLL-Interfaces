////////////////////////////////////////////////////////////////////////
//
// SchemaTypeCalendar.h
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "Altova.h"
#include "AltovaException.h"
#include <math.h>
#include <time.h>

#include "SchemaTypeCalendar.h"



namespace altova {

	static const int aMonthStart[] = 
	{
		0,	// 1st of Jan
		31,	// 1st of Feb
		59,	// 1st of Mar
		90,	// 1st of Apr
		120, // 1st of May
		151, // 1st of Jun
		181, // 1st of Jul
		212, // 1st of Aug
		243, // 1st of Sep
		273, // 1st of Oct
		304, // 1st of Nov
		334, // 1st of Dec
		365, // 1st of next year
	};

	static const int aMonthStartLeap[] = 
	{
		0,	// 1st of Jan
		31,	// 1st of Feb
		60,	// 1st of Mar
		91,	// 1st of Apr
		121, // 1st of May
		152, // 1st of Jun
		182, // 1st of Jul
		213, // 1st of Aug
		244, // 1st of Sep
		274, // 1st of Oct
		305, // 1st of Nov
		335, // 1st of Dec
		366, // 1st of next year
	};

////////////////////////////////////////////////////////////////////////
//
//  CSchemaTypeCalendar
//
////////////////////////////////////////////////////////////////////////

bool	CSchemaTypeCalendar::IsConvertableTo( CSchemaType::ETypes eType ) const
{
	try
	{
		switch( eType )
		{
		case CSchemaType::k_Duration:	return &operator CSchemaTypeCalendar::CDuration() != NULL;
		case CSchemaType::k_Time:		return &operator CSchemaTypeCalendar::CTime() != NULL;
		case CSchemaType::k_Day:		return &operator CSchemaTypeCalendar::CDay() != NULL;
		case CSchemaType::k_Month:		return &operator CSchemaTypeCalendar::CMonth() != NULL;
		case CSchemaType::k_MonthDay:	return &operator CSchemaTypeCalendar::CMonthDay() != NULL;
		case CSchemaType::k_Year:		return &operator CSchemaTypeCalendar::CYear() != NULL;
		case CSchemaType::k_YearMonth:	return &operator CSchemaTypeCalendar::CYearMonth() != NULL;
		case CSchemaType::k_Date:		return &operator CSchemaTypeCalendar::CDate() != NULL;
		case CSchemaType::k_DateTime:	return &operator CSchemaTypeCalendar::CDateTime() != NULL;
		}
	}
	catch( CAltovaException& )
	{}
	return false;
}


//  Utility functions
////////////////////////////////////////////////////////////////////////

int CSchemaTypeCalendar::ParseInt(const TCHAR** pszData, const TCHAR* szEstimatedType, const TCHAR* szValue, const int nMin, const int nMax )
{
	TCHAR* szEndPtr;
	int n = _tcstol(*pszData, &szEndPtr, 10);
	if (*pszData == szEndPtr)
		ThrowFormatError();
	*pszData = szEndPtr;
	if ( ( nMin != INT_MIN  &&  n < nMin ) || ( nMax != INT_MAX  &&  n > nMax ) )
		ThrowOutOfRangeError();
	return n;
}


double CSchemaTypeCalendar::ParseDouble(const TCHAR** pszData, const TCHAR* szEstimatedType, const TCHAR* szValue)
{
	TCHAR* szEndPtr;
	double d = _tcstod(*pszData, &szEndPtr);
	if (*pszData == szEndPtr)
		ThrowFormatError();
	*pszData = szEndPtr;
	return d;
}


void CSchemaTypeCalendar::ParseChar(const TCHAR** pszData, TCHAR chValue, const TCHAR* szEstimatedType, const TCHAR* szValue)
{
	if (**pszData != chValue)
		ThrowFormatError();
	(*pszData)++;
}


inline double CSchemaTypeCalendar::fQuotient(double a, double b)
{
	return floor(a / b);
}


inline double CSchemaTypeCalendar::fQuotient(double a, double low, double high)
{
	return fQuotient(a - low, high - low);
}


inline double CSchemaTypeCalendar::modulo(double a, double b)
{
	return a - fQuotient(a, b) * b;
}


inline double CSchemaTypeCalendar::modulo(double a, double low, double high)
{
	return modulo(a - low, high - low) + low;
}


inline bool CSchemaTypeCalendar::isLeapYear(int year)
{
	return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));
}


int CSchemaTypeCalendar::maxDayInMonthFor(int year, int month)
{
	if (month == 4 || month == 6 || month == 9 || month == 11)
		return 30;
	else if (month == 2)
		return isLeapYear(year) ? 29 : 28;
	else
		return 31;
}


void CSchemaTypeCalendar::DateTimeAddDuration( int& nYear, int& nMonth, int& nDay, int& nHour, int& nMinute, double& dSecond, const CSchemaTypeCalendar::CDuration& dur )
{
	CSchemaTypeCalendar::CDateTime r ( nYear, nMonth, nDay, nHour, nMinute, dSecond );
	r = r + dur;
	nYear = r.nYear;
	nMonth = r.nMonth;
	nDay = r.nDay;
	nHour = r.nHour;
	nMinute = r.nMinute;
	dSecond = r.dSecond;
}


int CSchemaTypeCalendar::WriteTime( TCHAR* szTarget, size_t count, int nHour, int nMinute, double dSecond )
{
	if (dSecond - floor(dSecond) == 0)
	{
		return _sntprintf(szTarget, count, _T("%02i:%02i:%02.f"), nHour, nMinute, floor(dSecond));
	}
	else
	{
		TCHAR* szLast = szTarget + _sntprintf(szTarget, count, _T("%02i:%02i:%09.6f"), nHour, nMinute, dSecond);

		while (*--szLast == _T('0'))
			*szLast = 0;

		return (int) (szLast - szTarget);
	}
}


void CSchemaTypeCalendar::ParseTZ( CDateTimeBase& rTimezone, const TCHAR* szValue )
{
	const TCHAR* szTmp = szValue;

	if (*szTmp == 0)
	{
		rTimezone.nTZMode = CSchemaTypeCalendar::CDateTimeBase::TZ_Missing;
		rTimezone.nOffset = 0;
	}
	else if (*szTmp == _T('Z'))
	{
		rTimezone.nTZMode = CSchemaTypeCalendar::CDateTimeBase::TZ_UTC;
		rTimezone.nOffset = 0;
		if (*++szTmp)
			ThrowFormatError();
	}
	else
	{
		rTimezone.nTZMode = CSchemaTypeCalendar::CDateTimeBase::TZ_Offset;
		int nOffsetHour = ParseInt(&szTmp, _T("datetime BASE"), szValue, -24, 24 );
		ParseChar(&szTmp, _T(':'), _T("datetime BASE"), szValue);
		int nOffsetMinute = ParseInt(&szTmp, _T("datetime BASE"), szValue, 0, 59 );
		if (nOffsetHour < 0)
			rTimezone.nOffset = nOffsetHour * 60 - nOffsetMinute;
		else
			rTimezone.nOffset = nOffsetHour * 60 + nOffsetMinute;
		if (*szTmp)
			ThrowFormatError();
	}
}


void CSchemaTypeCalendar::WriteTZ( const CDateTimeBase& rTimezone, TCHAR* szTarget, size_t count )
{
	switch (rTimezone.nTZMode)
	{
	case CSchemaTypeCalendar::CDateTimeBase::TZ_UTC:
		_tcscat(szTarget, _T("Z"));
		break;
	
	case CSchemaTypeCalendar::CDateTimeBase::TZ_Offset:
		{
			size_t length = _tcslen(szTarget);
			_sntprintf( szTarget + length, count - length, _T("%c%02i:%02i"),
				rTimezone.nOffset < 0 ? _T('-') : _T('+'),
				abs( rTimezone.nOffset / 60 ),
				abs( rTimezone.nOffset % 60 )
				);
		}
		break;
	}
}


bool CSchemaTypeCalendar::ParseDateTime( const TCHAR* sz, unsigned nPartSpec, CData& data )
{
	bool bDatePart = ( nPartSpec & ( k_PartYear | k_PartMonth | k_PartDay ) ) != 0;
	bool bTimePart = ( nPartSpec & ( k_PartTime ) ) != 0;

	data.nYear = 0;
	data.nMonth = 0; // month is 0 when date is not requested.
	data.nDay = 0; // day is 0 when date is not requested.
	data.nHour = 0;
	data.nMinute = 0;
	data.dSecond = 0;
	data.nTimezoneOffset = -32768;

	if ( bDatePart )
	{
		// parse date
		bool bNegative = CheckAndAdvance( sz, _T('-') );

		if ( nPartSpec & k_PartYear ) 
		{
			int digits = 0;
			unsigned year = 0;						
			while ( ReadDigitAndAdvance( sz, year, 1, 9 ) )
			{
				data.nYear = data.nYear * 10 + year;
				digits += 1;
				year = 0;
				if (digits >= 8) // overflow
					return false;
			}			 
			if ( digits < 4 ) // invalid.
				return false;
			if ( digits > 4 && data.nYear < 10000 )
				return false;
			if (bNegative) 
				data.nYear = -data.nYear;
		} 

		if ( nPartSpec & ( k_PartMonth | k_PartDay ) ) 
		{
			if ( !CheckAndAdvance( sz, _T('-') ) ) return false;

			if ( nPartSpec & k_PartMonth )
			{
				unsigned  month = 0;
				if ( !ReadDigitAndAdvance( sz, month, 10, 1 ) ) return false;
				if ( !ReadDigitAndAdvance( sz, month, 1, month < 10 ? 9 : 2 ) ) return false;
				if ( month == 0 ) return false;
				data.nMonth = ( unsigned char ) month;
			}

			if ( nPartSpec & ( k_PartDay ) ) 
			{
				if ( !CheckAndAdvance( sz, _T('-') ) ) return false;

				unsigned char maxFirstDigit = data.nMonth != 2 ? 3 : 2;

				unsigned  day = 0;
				// complicate things by making them complicated.
				if ( !ReadDigitAndAdvance( sz, day, 10, maxFirstDigit ) ) return false;
				if ( !ReadDigitAndAdvance( sz, day, 1, 9 ) ) return false;
				if ( day == 0 || day > 31 ) return false;
				
				if ( nPartSpec & k_PartMonth )
				{
					bool b1 = data.nMonth <= 7;
					bool b2 = ( data.nMonth & 1 ) == 0;

					// month 1, 3, 5, 7, 8, 10, 12
					if ( b1 == b2 && day > 30 )
						return false;

					// february.
					if ( data.nMonth == 2 && day > 29 )
						return false;

					// leap years.
					if ( data.nMonth == 2 && ( nPartSpec & k_PartYear ) && 
						( data.nYear % 4 != 0 || data.nYear % 100 == 0 ) && data.nYear % 400 != 0 &&
						day > 28 )
						return false;
				}
				data.nDay = day;
			}
		}	

		if ( bTimePart )
		{
			// a 'T' must follow
			if ( !CheckAndAdvance( sz, _T('T') ) ) return false;
		}
	}

	if ( bTimePart )
	{
		// check format here
		
		// hour from 0 to 2
		unsigned  hour = 0, minute = 0, second = 0;
		if ( !ReadDigitAndAdvance( sz, hour, 10, 2 ) ) return false;
		if ( !ReadDigitAndAdvance( sz, hour, 1, hour < 20 ? 9 : 4 ) ) return false;
		if ( !CheckAndAdvance( sz, _T(':') ) ) return false;
		unsigned char maxFirstDigit = hour == 24 ? 0 : 5;
		unsigned char maxSecondDigit = hour == 24 ? 0 : 9;
		if ( !ReadDigitAndAdvance( sz, minute, 10, maxFirstDigit ) ) return false;
		if ( !ReadDigitAndAdvance( sz, minute, 1, maxSecondDigit ) ) return false;
		if ( !CheckAndAdvance( sz, _T(':') ) ) return false;
		if ( !ReadDigitAndAdvance( sz, second, 10, maxFirstDigit ) ) return false;
		if ( !ReadDigitAndAdvance( sz, second, 1, maxSecondDigit ) ) return false;

		data.nHour = hour;
		data.nMinute = minute;
		data.dSecond = second;

		if ( CheckAndAdvance( sz, _T('.') ) )
		{
			// fraction. do whatever seems fit.
			unsigned val = 0;
			int digits = 0;
			while ( ReadDigitAndAdvance( sz, val, 1, 9) )
			{
				val *= 10;
				digits += 1;
				if ( digits >= 8 ) // precision loss - ignore
					break;
			}

			if ( digits == 0 )
				return false;

			data.dSecond += val * pow( 10.0, -digits - 1 );

			// skip any further digits.
			while ( ReadDigitAndAdvance( sz, val, 0, 9) ) 
				;		
		}
	}

	// timezone
	if ( *sz == _T('Z') )
	{
		// timezone specified, it is UTC.
		data.nTimezoneOffset = 0;
		++sz;
	}
	else if ( *sz == _T('+') || *sz == _T('-') )
	{
		// timezone offset, in hour:minute format
		bool bNegative = *sz == _T('-');
		++sz;
		
		// do not check the hour part, for those who are obscure.
		unsigned temp = 0;
		if ( !ReadDigitAndAdvance( sz, temp, 600, 9 ) ) return false;
		if ( !ReadDigitAndAdvance( sz, temp, 60, 9 ) ) return false;
		if ( !CheckAndAdvance( sz, _T(':') ) ) return false;
		if ( !ReadDigitAndAdvance( sz, temp, 10, 5 ) ) return false;
		if ( !ReadDigitAndAdvance( sz, temp, 1, 9 ) ) return false;

		data.nTimezoneOffset = bNegative ? -( int )temp : ( int )temp;
	}

	if ( *sz != 0 )
		return false;

	return true;
}


bool CSchemaTypeCalendar::IsStdDigit( TCHAR c )
{
	return c >= _T('0') && c <= _T('9');
}

bool CSchemaTypeCalendar::CheckAndAdvance( const TCHAR*& sz, TCHAR value )
{
	if ( *sz == value ) 
	{
		++sz;
		return true;
	}
	return false;
}

bool CSchemaTypeCalendar::ReadDigitAndAdvance( const TCHAR*& sz, unsigned& value, unsigned scale, unsigned char maxDigit )
{
	if ( !IsStdDigit( *sz ) )
		return false;
	unsigned val = ( *sz - _T('0') );
	if ( val > maxDigit )
		return false;
	value += scale * val;
	++sz;
	return true;
}




void CSchemaTypeCalendar::CDuration::SetDayTimeValue(TTimeValue tvDayTimeValue)
{
	if (tvDayTimeValue < 0)
	{
		bPositive = false;
		tvDayTimeValue = -tvDayTimeValue;
	}
	else
	{
		bPositive = true;
	}

	GetTimeFromTimeValue(tvDayTimeValue, nHour, nMinute, dSecond);
	nDay = GetDayNumberFromTimeValue(tvDayTimeValue);
}


void CSchemaTypeCalendar::CDuration::SetYearMonthValue(int nYearMonthValue)
{
	if (nYearMonthValue < 0)
	{
		bPositive = false;
		nYearMonthValue = -nYearMonthValue;
	}
	else
	{
		bPositive = true;
	}

	nYear = nYearMonthValue / 12;
	nMonth = nYearMonthValue % 12;	
}


CSchemaTypeCalendar::TTimeValue CSchemaTypeCalendar::GetTimeValue( 
	int nYear, int nMonth, int nDay, int nHour, int nMinute, double dSecond, int nTZOffset)
{
	TTimeValue nValue = 0; // 0001-01-01T00:00:00.000Z		

	int nMonthRem = ( nMonth - 1 ) % 12;
	if ( nMonthRem < 0 ) nMonthRem += 12;
	nYear += ( nMonth - nMonthRem - 1 ) / 12;
	nMonth = nMonthRem + 1;

	int nYearRed = nYear - 1;
	nValue += ( nYearRed / 400 ) * (303 * 365 + 97 * 366);
	nYearRed %= 400;
	nValue += ( nYearRed / 100 ) * (76 * 365 + 24 * 366);
	nYearRed %= 100;
	nValue += ( nYearRed / 4 ) * (365 * 3 + 366);
	nYearRed %= 4;
	nValue += nYearRed * 365; 

	if ( ( nYear % 4 == 0 ) && ( ( nYear % 100 != 0 ) || ( nYear % 400 == 0 ) ) )
		nValue += aMonthStartLeap[ nMonth - 1 ];
	else
		nValue += aMonthStart[ nMonth - 1 ];

	// add day (1-31)
	nValue += nDay - 1;

	nValue = nValue * 24 + nHour;
	nValue = nValue * 60 + nMinute - nTZOffset;
	nValue = ( TTimeValue )( ( nValue * 60 + dSecond ) * 1000 );
	return nValue;
}

void CSchemaTypeCalendar::GetTimeFromTimeValue( 
	TTimeValue tvTime, int& rnHour, int& rnMinute, double& rdSecond)
{
	tvTime %= (86400 * 1000);
	if ( tvTime < 0 )
		tvTime += 86400 * 1000;

	rdSecond = ((double)(tvTime % (60 * 1000))) / 1000;
	tvTime /= 60 * 1000;
	rnMinute = (int) (tvTime % 60);
	tvTime /= 60;
	rnHour = (int) (tvTime % 24);
}


int CSchemaTypeCalendar::GetDayNumberFromTimeValue(TTimeValue tvTime)
{
	return (int) (tvTime / (86400 * 1000));
}

void CSchemaTypeCalendar::GetDateFromTimeValue(
	TTimeValue tvTime, int& rnYear, int& rnMonth, int& rnDay)
{
	CSchemaTypeCalendar::TTimeValue tvDayTime = tvTime % (86400 * 1000);
	int nDays = GetDayNumberFromTimeValue( tvTime );
	rnYear = 1; 
	rnMonth = 1;
	rnDay = 1;

	int nDayRem = nDays % (303 * 365 + 97 * 366);
	if ( nDayRem < 0 ) nDayRem += (303 * 365 + 97 * 366);
	rnYear += 400 * ( (nDays - nDayRem) / (303 * 365 + 97 * 366) );
	if ( nDayRem == (303 * 365 + 97 * 366) - 1 )
	{
		rnYear += 399; 
		nDayRem = 365;
	}
	else
	{
		rnYear += 100 * ( nDayRem / (76 * 365 + 24 * 366) );
		nDayRem %= (76 * 365 + 24 * 366);
		rnYear += 4 * ( nDayRem / (365 * 3 + 366) );
		nDayRem %= (365 * 3 + 366);
		if ( nDayRem == (365 * 3 + 366) - 1 ) // last day of leap year
		{
			rnYear += 3; 
			nDayRem = 365;
		}
		else
		{
			rnYear += nDayRem / 365;
			nDayRem %= 365;
		}
	}

	const int* pMonthStarts;
	if ( ( rnYear % 4 == 0 ) && ( ( rnYear % 100 != 0 ) || ( rnYear % 400 == 0 ) ) )
		pMonthStarts = aMonthStartLeap;
	else
		pMonthStarts = aMonthStart;

	while ( nDayRem >= pMonthStarts[ rnMonth ] )
		++rnMonth;
	
	rnDay = nDayRem - pMonthStarts[ rnMonth - 1 ] + 1;
}



////////////////////////////////////////////////////////////////////////
//
//  Operators
//
////////////////////////////////////////////////////////////////////////

// CSchemaDuration
CSchemaDuration ALTOVA_DECLSPECIFIER operator+(const CSchemaDuration& dur1, const CSchemaDuration& dur2)
{
	CSchemaTypeCalendar::CDuration dur;

	int nYM1 = dur1.GetValue().GetYearMonthValue();
	int nYM2 = dur2.GetValue().GetYearMonthValue();
	CSchemaTypeCalendar::TTimeValue tv1 = dur1.GetValue().GetDayTimeValue();
	CSchemaTypeCalendar::TTimeValue tv2 = dur2.GetValue().GetDayTimeValue();

	int nYM = nYM1 + nYM2;
	CSchemaTypeCalendar::TTimeValue tv = tv1 + tv2;

	if ( ( nYM < 0 && tv > 0 ) || ( nYM > 0 && tv < 0 ) )
		throw CAltovaException(CAltovaException::eError1, _T("duration sign cannot be determined."));

	if ( nYM )
		dur.SetYearMonthValue( nYM );
	if ( tv )
		dur.SetDayTimeValue( tv );
	
	return dur;
}


// CSchemaDate

bool ALTOVA_DECLSPECIFIER operator==(const CSchemaDate& t1, const CSchemaDate& t2)
{
	if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
		return t1.GetValue().GetTimeValue() == t2.GetValue().GetTimeValue();
	else
		return false;
}


bool ALTOVA_DECLSPECIFIER operator<(const CSchemaDate& t1, const CSchemaDate& t2)
{
	if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
		return t1.GetValue().GetTimeValue() < t2.GetValue().GetTimeValue();
	else
		return t1.GetValue().GetTimeValue() < t2.GetValue().GetTimeValue() - 14 * 3600 * 1000;
}


bool ALTOVA_DECLSPECIFIER operator!=(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return !(t1 == t2);
}


bool ALTOVA_DECLSPECIFIER operator<=(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return t1 < t2 || t1 == t2;
}


bool ALTOVA_DECLSPECIFIER operator>(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return t2 < t1;
}


bool ALTOVA_DECLSPECIFIER operator>=(const CSchemaDate& t1, const CSchemaDate& t2)
{
	return t2 < t1 || t1 == t2;
}


// CSchemaTime

bool ALTOVA_DECLSPECIFIER operator==(const CSchemaTime& t1, const CSchemaTime& t2)
{
	if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
		return t1.GetValue().GetTimeValue() == t2.GetValue().GetTimeValue();
	else
		return false; 
}


bool ALTOVA_DECLSPECIFIER operator<(const CSchemaTime& t1, const CSchemaTime& t2)
{
	if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
		return t1.GetValue().GetTimeValue() < t2.GetValue().GetTimeValue();
	else
		return t1.GetValue().GetTimeValue() < t2.GetValue().GetTimeValue() - 14 * 3600 * 1000;
}


bool ALTOVA_DECLSPECIFIER operator!=(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return !(t1 == t2);
}


bool ALTOVA_DECLSPECIFIER operator<=(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return t1 < t2 || t1 == t2;
}


bool ALTOVA_DECLSPECIFIER operator>(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return t2 < t1;
}


bool ALTOVA_DECLSPECIFIER operator>=(const CSchemaTime& t1, const CSchemaTime& t2)
{
	return t2 < t1 || t1 == t2;
}


// CSchemaDateTime

bool ALTOVA_DECLSPECIFIER operator==(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
		return t1.GetValue().GetTimeValue() == t2.GetValue().GetTimeValue();
	else
		return false; 
}


bool ALTOVA_DECLSPECIFIER operator<(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
		return t1.GetValue().GetTimeValue() < t2.GetValue().GetTimeValue();
	else
		return t1.GetValue().GetTimeValue() < t2.GetValue().GetTimeValue() - 14 * 3600 * 1000;
}


bool ALTOVA_DECLSPECIFIER operator!=(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return !(t1 == t2);
}


bool ALTOVA_DECLSPECIFIER operator<=(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return t1 < t2 || t1 == t2;
}


bool ALTOVA_DECLSPECIFIER operator>(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return t2 < t1;
}


bool ALTOVA_DECLSPECIFIER operator>=(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	return t2 < t1 || t1 == t2;
}


// mixed

CSchemaDate ALTOVA_DECLSPECIFIER operator+(const CSchemaDate& t, const CSchemaDuration& dur)
{
	CSchemaTypeCalendar::CDateTime r ( t.GetValue().nYear, t.GetValue().nMonth, t.GetValue().nDay, 0, 0, 0.0 );
	r.nTZMode = t.GetValue().nTZMode;
	r.nOffset = t.GetValue().nOffset;

	// datetime addition
	r = r + dur;
	CSchemaTypeCalendar::CDate result( r.nYear, r.nMonth, r.nDay );
	result.nTZMode = r.nTZMode;
	result.nOffset = r.nOffset;
	return result;
}

CSchemaDuration ALTOVA_DECLSPECIFIER operator-(const CSchemaDate& t1, const CSchemaDate& t2)
{
	CSchemaTypeCalendar::CDuration dur;
	dur.SetDayTimeValue( t1.GetValue().GetTimeValue() - t2.GetValue().GetTimeValue() );
	return dur;
}

CSchemaTime ALTOVA_DECLSPECIFIER operator+(const CSchemaTime& t, const CSchemaDuration& dur)
{
	CSchemaTypeCalendar::CDateTime r ( 1, 1, 1, t.GetValue().nHour, t.GetValue().nMinute, t.GetValue().dSecond );
	r.nTZMode = t.GetValue().nTZMode;
	r.nOffset = t.GetValue().nOffset;
	r = r + dur;	

	CSchemaTypeCalendar::CTime result( r.nHour, r.nMinute, r.dSecond );
	result.nTZMode = r.nTZMode;
	result.nOffset = r.nOffset;
	return result;
}


CSchemaDuration ALTOVA_DECLSPECIFIER operator-(const CSchemaTime& t1, const CSchemaTime& t2)
{
	CSchemaTypeCalendar::CDuration dur;
	dur.SetDayTimeValue( t1.GetValue().GetTimeValue() - t2.GetValue().GetTimeValue() );
	return dur;
}


CSchemaDateTime ALTOVA_DECLSPECIFIER operator+(const CSchemaDateTime& t, const CSchemaDuration& dur)
{
	CSchemaTypeCalendar::CDateTime r ( t.GetValue() );
	
	// according to http://dev12/www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTimes
	r.nMonth += dur.GetValue().GetYearMonthValue();
	int nYearsOverflow;

	if (r.nMonth >= 1)
		nYearsOverflow = (r.nMonth - 1) / 12;
	else
		nYearsOverflow = (r.nMonth - 12) / 12;
	r.nMonth -= nYearsOverflow * 12;		
	if ( nYearsOverflow > 0 && r.nYear < 0 && nYearsOverflow >= -r.nYear )
		r.nYear += nYearsOverflow + 1; // skip year zero
	else if ( nYearsOverflow < 0 && r.nYear > 0 && -nYearsOverflow >= r.nYear )
		r.nYear += nYearsOverflow - 1; // skip year zero
	else
		r.nYear += nYearsOverflow;

	const int* pMonthStart;
	if ( ( r.nYear % 4 == 0 ) && (!( r.nYear % 100 == 0 ) || r.nYear % 400 == 0 ) )
		pMonthStart = aMonthStartLeap;
	else
		pMonthStart = aMonthStart;

	int nDaysInMonth = pMonthStart[r.nMonth] - pMonthStart[r.nMonth - 1];	
	if ( r.nDay > nDaysInMonth )
		r.nDay = nDaysInMonth;

	CSchemaTypeCalendar::TTimeValue tv = r.GetTimeValue() + dur.GetValue().GetDayTimeValue();

	// timezone offset:
	tv += r.nOffset * 60000;
	
	CSchemaTypeCalendar::GetDateFromTimeValue( tv, r.nYear, r.nMonth, r.nDay );
	CSchemaTypeCalendar::GetTimeFromTimeValue( tv, r.nHour, r.nMinute, r.dSecond );

	return r;
}


CSchemaDuration ALTOVA_DECLSPECIFIER operator-(const CSchemaDateTime& t1, const CSchemaDateTime& t2)
{
	CSchemaTypeCalendar::CDuration dur;
	dur.SetDayTimeValue( t1.GetValue().GetTimeValue() - t2.GetValue().GetTimeValue() );
	return dur;
}




////////////////////////////////////////////////////////////////////////
//
//  CSchemaDuration
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaDuration::InternalDTParse( const TCHAR* szValue )
{
    const TCHAR* szTmp = szValue;
    m_Value.InitZero(); // set everything to zero before.
    if ( *szTmp == _T('-') )
    {
        m_Value.bPositive = false;
        ++szTmp;
    }

    // '' and '-' are not valid, and a P has to appear here.
    if ( *szTmp != _T('P') )
        ThrowFormatError();
    ++szTmp;

    // algorithm will progress through states, order is important.
    enum TState
    {
        k_Year,
        k_Month,
        k_Day,
        k_Time,
        k_Hour,
        k_Minute,
        k_Second,
        k_Fraction,
        k_Bad,
    } state = k_Year;

    while ( *szTmp )
    {
        // no more data allowed?
        if ( state == k_Bad )
            ThrowFormatError();

        // check if ymd part is over
        if ( *szTmp == _T('T') )
        {
            if ( state >= k_Hour )
                ThrowFormatError();
            state = k_Hour;
            ++szTmp;
        }
        
        if ( state == k_Time )
            ThrowFormatError();

        // now a digit has to follow, and probably more than one
        if ( *szTmp < _T('0') || *szTmp > _T('9') )
            ThrowFormatError();

        unsigned val = 0;
        unsigned digits = 0;
        while ( *szTmp >= _T('0') && *szTmp <= _T('9') )
        {
            if ( val >= 100000000u ) // xe8 * 10 may be >= 2^32
                ThrowFormatError();

            val = val * 10 + ( *szTmp - _T('0') );
            digits += 1;
            ++szTmp;
        }

        TState foundState = k_Bad;
        
        switch ( *szTmp )
        {
            case _T('Y'): if ( state >= k_Hour ) foundState = k_Bad; else foundState = k_Year; break;
            case _T('M'): if ( state >= k_Hour ) foundState = k_Minute; else foundState = k_Month; break;
            case _T('D'): if ( state >= k_Hour ) foundState = k_Bad; else foundState = k_Day; break;
            case _T('H'): if ( state >= k_Hour ) foundState = k_Hour; else foundState = k_Bad; break;
            case _T('S'): if ( state >= k_Fraction ) foundState = k_Fraction;
            else if ( state >= k_Hour) foundState = k_Second; else foundState = k_Bad; break;
            case _T('.'): if ( state >= k_Hour ) foundState = k_Second; else foundState = k_Bad; break;
        }

        // when finding something that already occurred (or is otherwise invalid), bark.
        if ( foundState == k_Bad || foundState < state )
            ThrowFormatError();

        ++szTmp;

        switch ( foundState )
        {
            case k_Year: m_Value.nYear = val; break;
            case k_Month: m_Value.nMonth= val; break;
            case k_Day: m_Value.nDay = val; break;
            case k_Hour: m_Value.nHour = val; break;
            case k_Minute: m_Value.nMinute = val; break;
            case k_Second: m_Value.dSecond = val; break;
            case k_Fraction: m_Value.dSecond += (double)val * pow(0.1, (int)digits) ; break;
        }

        state = ( TState )( foundState + 1 );
    }

    // if still at start state this means someone 'forgot' to add any data (e.g. 'P' alone)
    if ( state == k_Year )
        ThrowFormatError();
}



template<>
        tstring CSchemaDuration::ToString() const
{
    TCHAR szResult[64];
    TCHAR* szEnd = szResult + 63;
    TCHAR* szTmp = szResult;

    if (!m_Value.bPositive)
        *szTmp++ = _T('-');
    *szTmp++ = _T('P');
    if (m_Value.nYear != 0)
        szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%iY"), abs( m_Value.nYear ));
    if (m_Value.nMonth != 0)
        szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%iM"), abs( m_Value.nMonth ));
    if (m_Value.nDay != 0)
        szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%iD"), abs( m_Value.nDay ));
    if (m_Value.nHour != 0 || m_Value.nMinute != 0 || m_Value.dSecond != 0)
    {
        *szTmp++ = _T('T');
        if (m_Value.nHour != 0)
            szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%iH"), abs( m_Value.nHour ));
        if (m_Value.nMinute != 0)
            szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%iM"), abs( m_Value.nMinute ));
        if (m_Value.dSecond != 0)
        {
            double d = m_Value.dSecond < 0 ? m_Value.dSecond * -1 : m_Value.dSecond;
            if (m_Value.dSecond - floor(m_Value.dSecond) == 0)
            {
                szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%01.f"), d);
            }
            else
            {
                szTmp += _sntprintf(szTmp, szEnd - szTmp, _T("%.6f"), d);
                while (*(szTmp-1) == _T('0'))
                    *--szTmp = 0;
            }
            *szTmp++ = _T('S');
        }
    }
    if (szTmp[-1] == _T('P'))
    {
        *szTmp++ = _T('T');
        *szTmp++ = _T('0');
        *szTmp++ = _T('S');
    }
    *szTmp = 0;

    return szResult;
}


template<>
        CSchemaDuration::operator CSchemaTypeCalendar::CDuration() const
{
    return m_Value;
}


template<>
        CSchemaDuration::operator CSchemaTypeCalendar::CTime() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CTime();

    if( m_Value.nDay>0 || m_Value.nMonth>0 || m_Value.nYear>0 || !m_Value.bPositive )
        ThrowValuesNotConvertableError();

    CSchemaTypeCalendar::CTime dt;
    dt.nHour = m_Value.nHour;
    dt.nMinute = m_Value.nMinute;
    dt.dSecond = m_Value.dSecond;
    return dt;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDate
//
////////////////////////////////////////////////////////////////////////


template<>
        void CSchemaDate::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartDate, data))
        ThrowFormatError();
    m_Value.nYear = data.nYear;
    m_Value.nMonth = data.nMonth;
    m_Value.nDay = data.nDay;

    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaDate::ToString() const
{
    TCHAR szTmp[32];
    int nPos;
    if (m_Value.nYear < 0)
    {
        nPos = _sntprintf( szTmp, 32, _T("-%04i-%02i-%02i"), -m_Value.nYear, m_Value.nMonth, m_Value.nDay );
    }
    else
    {
        nPos = _sntprintf( szTmp, 32, _T("%04i-%02i-%02i"), m_Value.nYear, m_Value.nMonth, m_Value.nDay );
    }
    WriteTZ( m_Value, szTmp + nPos, 32 - nPos );
    return szTmp;
}


template<>
        CSchemaDate::operator CSchemaTypeCalendar::CDate() const
{
    return m_Value;
}



template<>
        CSchemaDate::operator CSchemaTypeCalendar::CDateTime() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CDateTime();

    CSchemaTypeCalendar::CDateTime  dt;
    dt.nYear = m_Value.nYear;
    dt.nMonth = m_Value.nMonth;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}

template<>
        CSchemaDate::operator CSchemaTypeCalendar::CDay() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CDay();

    CSchemaTypeCalendar::CDay   dt;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}

template<>
        CSchemaDate::operator CSchemaTypeCalendar::CMonth() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CMonth();

    CSchemaTypeCalendar::CMonth dt;
    dt.nMonth = m_Value.nMonth;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}

template<>
        CSchemaDate::operator CSchemaTypeCalendar::CMonthDay() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CMonthDay();

    CSchemaTypeCalendar::CMonthDay  dt;
    dt.nMonth = m_Value.nMonth;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}

template<>
        CSchemaDate::operator CSchemaTypeCalendar::CYear() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CYear();

    CSchemaTypeCalendar::CYear  dt;
    dt.nYear = m_Value.nYear;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}

template<>
        CSchemaDate::operator CSchemaTypeCalendar::CYearMonth() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CYearMonth();

    CSchemaTypeCalendar::CYearMonth dt;
    dt.nYear = m_Value.nYear;
    dt.nMonth = m_Value.nMonth;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaTime
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaTime::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartTime, data))
        ThrowFormatError();
    m_Value.nHour = data.nHour;
    m_Value.nMinute = data.nMinute;
    m_Value.dSecond = data.dSecond;

    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaTime::ToString() const
{
    TCHAR szTmp[64];
    int nPos = WriteTime(szTmp, 64, m_Value.nHour, m_Value.nMinute, m_Value.dSecond);
    WriteTZ( m_Value, szTmp + nPos, 64 - nPos);
    return szTmp;
}


template<>
        CSchemaTime::operator CSchemaTypeCalendar::CTime() const
{
    return m_Value;
}


template<>
        CSchemaTime::operator CSchemaTypeCalendar::CDuration() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CDuration();

    CSchemaTypeCalendar::CDuration  dur;
    dur.nHour = m_Value.nHour;
    dur.nMinute = m_Value.nMinute;
    dur.dSecond = m_Value.dSecond;
    return dur;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDateTime
//
////////////////////////////////////////////////////////////////////////


template<>
        void CSchemaDateTime::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartTime|CSchemaCalendar::k_PartDate, data))
        ThrowFormatError();
    m_Value.nYear = data.nYear;
    m_Value.nMonth = data.nMonth;
    m_Value.nDay = data.nDay;
    m_Value.nHour = data.nHour;
    m_Value.nMinute = data.nMinute;
    m_Value.dSecond = data.dSecond;

    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaDateTime::ToString() const
{
    TCHAR szTmp[64];
    int nPos;
    if (m_Value.nYear < 0)
        nPos = _sntprintf(szTmp, 64, _T("-%04i-%02i-%02iT"), -m_Value.nYear, m_Value.nMonth, m_Value.nDay);
    else
        nPos = _sntprintf(szTmp, 64, _T("%04i-%02i-%02iT"), m_Value.nYear, m_Value.nMonth, m_Value.nDay);
    nPos += WriteTime( szTmp + nPos, 64 - nPos, m_Value.nHour, m_Value.nMinute, m_Value.dSecond);
    WriteTZ( m_Value, szTmp + nPos, 64 - nPos);
    return szTmp;
}





template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CDateTime() const
{
    return m_Value;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CDate() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CDate();

    CSchemaTypeCalendar::CDate  dt;
    dt.nYear = m_Value.nYear;
    dt.nMonth = m_Value.nMonth;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CDay() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CDay();

    CSchemaTypeCalendar::CDay   dt;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CMonth() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CMonth();

    CSchemaTypeCalendar::CMonth dt;
    dt.nMonth = m_Value.nMonth;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CMonthDay() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CMonthDay();

    CSchemaTypeCalendar::CMonthDay  dt;
    dt.nMonth = m_Value.nMonth;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CTime() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CTime();

    CSchemaTypeCalendar::CTime  dt;
    dt.nHour = m_Value.nHour;
    dt.nMinute = m_Value.nMinute;
    dt.dSecond = m_Value.dSecond;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CYear() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CYear();

    CSchemaTypeCalendar::CYear  dt;
    dt.nYear = m_Value.nYear;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaDateTime::operator CSchemaTypeCalendar::CYearMonth() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CYearMonth();

    CSchemaTypeCalendar::CYearMonth dt;
    dt.nYear = m_Value.nYear;
    dt.nMonth = m_Value.nMonth;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaYear
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaYear::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartYear, data))
        ThrowFormatError();
    m_Value.nYear = data.nYear;
    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaYear::ToString() const
{
    TCHAR szTmp[32];
    int nPos;
    if (m_Value.nYear < 0)
        nPos = _sntprintf(szTmp, 32, _T("-%04i"), -m_Value.nYear);
    else
        nPos = _sntprintf(szTmp, 32, _T("%04i"), m_Value.nYear);
    WriteTZ( m_Value, szTmp + nPos, 32 - nPos );
    return szTmp;
}


template<>
        CSchemaYear::operator CSchemaTypeCalendar::CYear() const
{
    return m_Value;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaYearMonth
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaYearMonth::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartYear|CSchemaCalendar::k_PartMonth, data))
        ThrowFormatError();
    m_Value.nYear = data.nYear;
    m_Value.nMonth = data.nMonth;
    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaYearMonth::ToString() const
{
    TCHAR szTmp[32];
    int nPos;
    if (m_Value.nYear < 0)
        nPos = _sntprintf(szTmp, 32, _T("-%04i-%02i"), -m_Value.nYear, m_Value.nMonth);
    else
        nPos = _sntprintf(szTmp, 32, _T("%04i-%02i"), m_Value.nYear, m_Value.nMonth);
    WriteTZ( m_Value, szTmp + nPos, 32 - nPos);
    return szTmp;
}


template<>
        CSchemaYearMonth::operator CSchemaTypeCalendar::CYearMonth() const
{
    return m_Value;
}


template<>
        CSchemaYearMonth::operator CSchemaTypeCalendar::CMonth() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CMonth();

    CSchemaTypeCalendar::CMonth dt;
    dt.nMonth = m_Value.nMonth;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaYearMonth::operator CSchemaTypeCalendar::CYear() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CYear();

    CSchemaTypeCalendar::CYear  dt;
    dt.nYear = m_Value.nYear;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaMonth
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaMonth::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartMonth, data))
        ThrowFormatError();
    m_Value.nMonth = data.nMonth;
    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaMonth::ToString() const
{
    TCHAR szTmp[32];
    int nPos = _sntprintf(szTmp, 32, _T("--%02i"), m_Value.nMonth);
    WriteTZ( m_Value, szTmp + nPos, 32 - nPos );
    return szTmp;
}


template<>
        CSchemaMonth::operator CSchemaTypeCalendar::CMonth() const
{
    return m_Value;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaMonthDay
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaMonthDay::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartMonth|CSchemaCalendar::k_PartDay, data))
        ThrowFormatError();
    m_Value.nMonth = data.nMonth;
    m_Value.nDay = data.nDay;
    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaMonthDay::ToString() const
{
    TCHAR szTmp[32];
    int nPos = _sntprintf( szTmp, 32, _T("--%02i-%02i"), m_Value.nMonth, m_Value.nDay );
    WriteTZ( m_Value, szTmp + nPos, 32 - nPos);
    return szTmp;
}


template<>
        CSchemaMonthDay::operator CSchemaTypeCalendar::CMonthDay() const
{
    return m_Value;
}


template<>
        CSchemaMonthDay::operator CSchemaTypeCalendar::CDay() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CDay();

    CSchemaTypeCalendar::CDay   dt;
    dt.nDay = m_Value.nDay;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


template<>
        CSchemaMonthDay::operator CSchemaTypeCalendar::CMonth() const
{
    if( IsEmpty() )
        return CSchemaTypeCalendar::CMonth();

    CSchemaTypeCalendar::CMonth dt;
    dt.nMonth = m_Value.nMonth;
    dt.nTZMode = m_Value.nTZMode;
    dt.nOffset = m_Value.nOffset;
    return dt;
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaDay
//
////////////////////////////////////////////////////////////////////////
template<>
        void CSchemaDay::InternalDTParse( const TCHAR* szValue )
{
    CSchemaCalendar::CData data;
    if (!CSchemaCalendar::ParseDateTime(szValue, CSchemaCalendar::k_PartDay, data))
        ThrowFormatError();
    m_Value.nDay = data.nDay;
    switch(data.nTimezoneOffset)
    {
        case -32768:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Missing;
            m_Value.nOffset = 0;
            break;
        case 0:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_UTC;
            m_Value.nOffset = 0;
            break;
        default:
            m_Value.nTZMode = CSchemaTypeCalendar::CDateTime::TZ_Offset;
            m_Value.nOffset = data.nTimezoneOffset;
            break;
    }
}


template<>
        tstring CSchemaDay::ToString() const
{
    TCHAR szTmp[32];
    int nPos = _sntprintf(szTmp, 32, _T("---%02i"), m_Value.nDay);
    WriteTZ( m_Value, szTmp + nPos, 32 - nPos );
    return szTmp;
}


template<>
        CSchemaDay::operator CSchemaTypeCalendar::CDay() const
{
    return m_Value;
}


} // namespace altova
