////////////////////////////////////////////////////////////////////////
//
// CAEX_ClassModelTest.cpp
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include <CAEX_ClassModel.h>
#include <CAEXDocument.h>
#include "testcases.h"

using namespace std;



#ifdef _DEBUG

	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
#endif

using namespace CAEX_ClassModel;

void Example()
{
	////////////////////////////////////////////////////////////////////
	//
	// TODO:
	//   Insert your code here...
	//
	// Example code to create and save a structure:
	//   CAEX_ClassModel::CCAEX_ClassModel doc = CAEX_ClassModel::CCAEX_ClassModel::CreateDocument();
	//   CAEX_ClassModel::CCAEXFileType root = doc.CAEXFile.append();
	//   ...
	//   doc.SetSchemaLocation(_T("C:/Projects/AutomationML/CAEX_ClassModel.xsd")); // optional
	//   doc.SaveToFile(_T("CAEX_ClassModel1.xml"), true);
	//
	// Example code to load and save a structure:
	   //CAEX_ClassModel::CCAEX_ClassModel doc = CAEX_ClassModel::CCAEX_ClassModel::LoadFromFile(_T("2008-04-16_AutomationML_DemoCell.aml"));
	//   CAEX_ClassModel::CCAEXFileType root = doc.CAEXFile.first();
	//   ...
	   //doc.SaveToFile(_T("CAEX_ClassModel1.xml"), true);
	//
    //Create a new CAEXDocument
    CAEXDocument *amlDocument = CAEXDocument::New_CAEXDocument();

    //Access the root element CAEXFile
    CAEXFileType *caexFile = amlDocument->getCAEXFile();

    //Create a new InstanceHierarchy "Project"
    InstanceHierarchyType *projectInstanceHierarchy = caexFile->New_InstanceHierarchy("Project");

    //Create SystemUnitClassLib "MyClassLib"
    SystemUnitClassLibType *myClassLib = caexFile->New_SystemUnitClassLibHierarchy("MyClassLib");

    //Create RoleClassLib "MyRoleClassLib"
    RoleClassLibType *myRoleClassLib = caexFile->New_RoleClassLibHierarchy("MyRoleClassLib");

    //add SystemUnitClass "MyRobot"
    SystemUnitFamilyType *myRobotClass = myClassLib->New_SystemUnitClass("MyRobot");

    //add descriptive text
    DescriptionType *description = myRobotClass->New_Description();
    *description = std::string("Definition of a robot");

    //add RoleClass "Robot"
    RoleFamilyType *robotRoleClass = myRoleClassLib->New_RoleClass("Robot");

    //get full path to RoleClass "Robot"
    string roleReference = myRoleClassLib->getFullNodePath(robotRoleClass->GetNode());

    //add SupportedRoleClass to MyRobot with reference to RoleClass "Robot"
    SupportedRoleClassType *supportedRole = myRobotClass->New_SupportedRoleClass(roleReference);

    //Create first instance of SystemUnitClass "MyRobot"
    TypeBase *firstClassInstance = myRobotClass->CreateClassInstance();

    //Get the referenced RoleClass
    RoleFamilyType *referencedRoleFamilyType = myRobotClass->getReferencedRoleClass(roleReference);

    //cast first instance of SystemUnitClass "MyRobot" to InternalElement.
    InternalElementType *myFirstRobot = (InternalElementType*)firstClassInstance;

    //Create an instance of RoleClass "Robot"
    TypeBase *roleRequirement = referencedRoleFamilyType->CreateClassInstance();

    //Insert RoleRequirement element
    myFirstRobot->Insert_Element(roleRequirement);

    //rename InternalElement to "MyFirstRobot"
    myFirstRobot->Name = std::string("MyFirstRobot");

    //Insert "MyFirstRobot" in InstanceHierarchy "Project"
    projectInstanceHierarchy->Insert_InternalElement(myFirstRobot);

    //Create second instance of SystemUnitClass "MyRobot"
    TypeBase *secondClassInstance = myRobotClass->CreateClassInstance();

    //Insert second instance of "MyRobot" in InstanceHierarchy "Project"
    //directly.
    //Doing this is an alternative to the above described way of adding the
    //first instance of "MyRobot" to InstanceHierarchy "Project"
    projectInstanceHierarchy->Insert_NewInstance(secondClassInstance);

    //cast second instance of "MyRobot" to InternalElement
    InternalElementType *mySecondRobot = (InternalElementType*)secondClassInstance;

    //Rename to "MySecondRobot"
    mySecondRobot->Name = std::string("MySecondRobot");

    //Add another instance of the referenced RoleClass "Robot" as
    //RoleRequirement to "MySecondRobot"
    TypeBase *secondRoleRequirement = referencedRoleFamilyType->CreateClassInstance();
    mySecondRobot->Insert_Element(secondRoleRequirement);

    //add COLLADARefernce to "MyFirstRobot"
    XMLCh *uri = xercesc::XMLString::transcode("file:///irb6640_235_255__01.dae#extraTag");
    xercesc::XMLUri *firstRoboterUri = new xercesc::XMLUri(uri);
    xercesc::XMLString::release(&uri);
    myFirstRobot->New_COLLADAReference(firstRoboterUri);

    //define FrameValues and add a Frame to "MyFirstRobot"
    FrameValues *myFirstRobotFrameValues = new FrameValues();
    myFirstRobotFrameValues->X = 2000;
    myFirstRobotFrameValues->RZ = 180;
    myFirstRobot->New_FrameAttribute(myFirstRobotFrameValues);

    //add COLLADARefernce to "MySecondRobot"
    uri = xercesc::XMLString::transcode("file:///kr125_3.co.dae#extraTag");
    xercesc::XMLUri *secondRoboterUri = new xercesc::XMLUri(uri);
    xercesc::XMLString::release(&uri);
    mySecondRobot->New_COLLADAReference(secondRoboterUri);

    //define FrameValues and add a Frame to "MySecondRobot"
    FrameValues *mySecondRobotFrameValues = new FrameValues();
    mySecondRobotFrameValues->X = -2000;
    mySecondRobot->New_FrameAttribute(mySecondRobotFrameValues);

    //Save file
    caexFile->FileName = "SampleFile.aml";
    amlDocument->SaveToFile("SampleFile.aml", true);

	////////////////////////////////////////////////////////////////////
}

void run_testcases()
{
    testcases tc;
    if (! tc.newDocument()) return;
    if (! tc.createCAEXStructure()) return;
    if (! tc.instanceHierarchyTests()) return;
    if (! tc.caexBasicObjectsTests()) return;
    if (! tc.writeDocument()) return;
}

void LoadSave(std::string filename)
{
    CAEXDocument *doc=CAEXDocument::LoadFromFile(filename);

    // list all internal elements
    std::vector<InternalElementType> ls=doc->getCAEXFile()->getAllInternalElementsWithInternalLinks();
    std::cout << "list has been retrieved. Now showing it:" << std::endl;

    for(std::vector<InternalElementType>::iterator it=ls.begin(); it!=ls.end(); it++)
    {
        InternalElementType element=*it;
        std::string name=element.Name;
        std::cout << "Internal Element's name is " << name << std::endl;
    }

    doc->SaveToFile("copy.aml", true);
}

int main(int argc, char* argv[], char* envp[])
{
	std::cout << "CAEX_ClassModel Test Application" << std::endl;

	try
	{
		xercesc::XMLPlatformUtils::Initialize();

        if (argc>1)
        {
            if (argv[1][0]=='-')
            {
                switch (argv[1][1])
                {
                case 't':
                    run_testcases();
                    return 0;
                default:
                    break;
                }
            }
            else
            {
                LoadSave(argv[1]);
            }
        }
        else
        {
            Example();
        }

		xercesc::XMLPlatformUtils::Terminate();

		std::cout << "OK" << std::endl;
		return 0;
	}
	catch (CXmlException& e)
	{
		std::cerr << "Error: " << e.GetInfo().c_str() << std::endl;
		return 1;
	}
	catch (xercesc::XMLException& e)
	{
		std::cerr << "Xerces XMLException: " << e.getSrcFile() << "("
			  << e.getSrcLine() << "): " << e.getMessage() << std::endl;
		return 1;
	}
	catch (xercesc::DOMException& e)
	{
		std::cerr << "Xerces DOMException " << e.code;
		if (e.msg)
			std::cerr << ": " << e.msg;
		std::cerr << std::endl;
		return 1;
	}
	catch (altova::Exception& exception)
	{
		std::cerr << "Altova Exception: " << exception.message() << std::endl;
		return 1;
	}
	catch (altova::Error& exception)
	{
		std::cerr << "Altova Error Exception: " << exception.message() << std::endl;
		return 1;
	}
	catch (std::exception& e)
	{
		std::cerr << "Standard Exception: " << e.what() << std::endl;
		return 1;
	}
	catch (...)
	{
		std::cerr << "Unknown error" << std::endl;
		return 1;
	}
}
