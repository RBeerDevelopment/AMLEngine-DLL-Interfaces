////////////////////////////////////////////////////////////////////////
//
// SchemaTypeString.h
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "Altova.h"
#include "AltovaException.h"
#include "SchemaTypeString.h"

namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  CSchemaString
//
////////////////////////////////////////////////////////////////////////

CSchemaString::CSchemaString( const double nValue )
{	
	m_Value = ( tstring )CSchemaDecimal( nValue );
	SetIsEmpty( false );
}




bool CSchemaString::ToBool() const
{
	if( !CSchemaType::ToBool() )
		return false;

	if( m_Value.size() == 0  ||
		m_Value == _T("0")  ||		// Hack because of confuse boolean-value handling of XPATH 1.0
		m_Value == _T("false") )	//   --,,--
		return false;

	return true;
}


CSchemaString::operator tstring() const
{
	if( IsEmpty() )
		return _T("");
	return m_Value;
}





void CSchemaString::Empty()
{
	CSchemaType::Empty();
	m_Value = _T("");
}


bool CSchemaString::Parse( const TCHAR* szValue )
{
	if( !CSchemaType::Parse( szValue ) )
		return false;

	m_Value = szValue;
	SetIsEmpty( 0==m_Value.size() );

	return !IsEmpty();
}


CSchemaType& CSchemaString::Assign( const CSchemaType& rOther )
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	m_Value = ( tstring )rOther;
	SetIsEmpty( 0==m_Value.size() );

	return *this;
}


CSchemaType::ETypes CSchemaString::NumericType() const
{
	if( m_Value.size()==0 )
		return CSchemaType::k_unknown;
	
	TCHAR* szEndPtr;
	const TCHAR* szData = m_Value.c_str();

	// check if boolean
	if( m_Value == _T("true") || m_Value == _T("false") )
		return CSchemaType::k_bool;

	// check if integer 
	__int64 i64 = _ttoi64(szData);
	if( i64 > _I64_MAX )
		return CSchemaType::k_unsigned_long;
	if( i64 < _I32_MIN  ||
		i64 > _UI32_MAX )
		return CSchemaType::k_long;
	long i = _tcstol(szData, &szEndPtr, 10);
	if( *szEndPtr == 0 )
	{	
		if( i < 0 )
		{	// signed
			if( i >= SCHAR_MIN )
				return CSchemaType::k_byte;
			if( i >= SHRT_MIN )
				return CSchemaType::k_short;
			return CSchemaType::k_int;
		}
		else
		{	// unsigned
			if( i <= UCHAR_MAX )
				return CSchemaType::k_unsigned_byte;
			if( i <= USHRT_MAX )
				return CSchemaType::k_unsigned_short;
			return CSchemaType::k_unsigned_int;
		}
	}

	// check floating-point
	double d = _tcstod(szData, &szEndPtr);
	if( *szEndPtr == 0 )
	{
		return CSchemaType::k_double;
		// NOTE: float and decimal are missing here.
	}

	// it is not a number
	return CSchemaType::k_unknown;
}


long CSchemaString::ToLong() const
{
	if( IsEmpty() )
		return (long)CSchemaInt();
	if( m_Value == _T("false") )
		return 0;
	if( m_Value == _T("true") )
		return 1;
	return (long)CSchemaInt(m_Value.c_str());
}

__int64 CSchemaString::ToInt64() const
{
	if( IsEmpty() )
		return (__int64)CSchemaLong();
	if( m_Value == _T("false") )
		return 0;
	if( m_Value == _T("true") )
		return 1;
	return (__int64)CSchemaLong(m_Value.c_str());
}

float CSchemaString::ToFloat() const
{
	if( IsEmpty() )
		return (float)CSchemaFloat();
	if( m_Value == _T("false") )
		return 0.0;
	if( m_Value == _T("true") )
		return 1.0;
	return (float)CSchemaFloat(m_Value.c_str());
}

double CSchemaString::ToDouble() const
{
	if( IsEmpty() )
		return (double)CSchemaDouble();
	if( m_Value == _T("false") )
		return 0.0;
	if( m_Value == _T("true") )
		return 1.0;
	return (double)CSchemaDouble(m_Value.c_str());
}



CSchemaType::ETypes CSchemaString::CalendarType() const
{
	if( m_Value.size()==0 )
		return CSchemaType::k_unknown;
	
	try
	{
		CSchemaDateTime r = CSchemaDateTime(m_Value.c_str());
		return CSchemaType::k_DateTime;	
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaDuration r = CSchemaDuration(m_Value.c_str());
		return CSchemaType::k_Duration;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaDate r = CSchemaDate(m_Value.c_str());
		return CSchemaType::k_Date;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaTime r = CSchemaTime(m_Value.c_str());
		return CSchemaType::k_Time;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaYearMonth r = CSchemaYearMonth(m_Value.c_str());
		return CSchemaType::k_YearMonth;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaMonthDay r = CSchemaMonthDay(m_Value.c_str());
		return CSchemaType::k_MonthDay;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaDay r = CSchemaDay(m_Value.c_str());
		return CSchemaType::k_Day;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaMonth r = CSchemaMonth(m_Value.c_str());
		return CSchemaType::k_Month;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaYear r = CSchemaYear(m_Value.c_str());
		return CSchemaType::k_Year;
	}
	catch( CAltovaException e ) {};

	return CSchemaType::k_unknown;
}

CSchemaString::operator CSchemaTypeCalendar::CDate() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDate();
	return CSchemaDate( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CDateTime() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDateTime();
	return CSchemaDateTime( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CDay() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDay();
	return CSchemaDay( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CDuration() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDuration();
	return CSchemaDuration( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CMonth() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CMonth();
	return CSchemaMonth( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CMonthDay() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CMonthDay();
	return CSchemaMonthDay( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CTime() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CTime();
	return CSchemaTime( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CYear() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CYear();
	return CSchemaYear( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CYearMonth() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CYearMonth();
	return CSchemaYearMonth( m_Value.c_str() );
}






} // namespace altova

