////////////////////////////////////////////////////////////////////////
//
// SchemaTypes.h
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_SCHEMATYPES_H_INCLUDED
#define ALTOVA_SCHEMATYPES_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include <stdlib.h>
#include <vector>

#include "StructInfo.h"
#include "xs-datetime.h"

namespace altova
{
	class ALTOVA_DECLSPECIFIER CoreTypes
	{
	public:		
		static int CastToInt(int i);
		static int CastToInt(unsigned int i);
		static int CastToInt(double d);
		static int CastToInt(const string_type& s);
		static int CastToInt(__int64 i);
		static int CastToInt(unsigned __int64 i);

		static unsigned CastToUInt(int i);
		static unsigned CastToUInt(unsigned int i);
		static unsigned CastToUInt(double d);
		static unsigned CastToUInt(const string_type& s);
		static unsigned CastToUInt(__int64 i);
		static unsigned CastToUInt(unsigned __int64 i);

		static __int64 CastToInt64(int i);
		static __int64 CastToInt64(unsigned int i);
		static __int64 CastToInt64(double d);
		static __int64 CastToInt64(const string_type& s);
		static __int64 CastToInt64(__int64 i);
		static __int64 CastToInt64(unsigned __int64 i);

		static unsigned __int64 CastToUInt64(int i);
		static unsigned __int64 CastToUInt64(unsigned int i);
		static unsigned __int64 CastToUInt64(double d);
		static unsigned __int64 CastToUInt64(const string_type& s);
		static unsigned __int64 CastToUInt64(__int64 i);
		static unsigned __int64 CastToUInt64(unsigned __int64 i);

		static double CastToDouble(int i);
		static double CastToDouble(unsigned i);
		static double CastToDouble(__int64 i);
		static double CastToDouble(unsigned __int64 i);
		static double CastToDouble(double d);
		static double CastToDouble(const string_type& s);

		static string_type CastToString(int i);
		static string_type CastToString(unsigned int i);
		static string_type CastToString(__int64 i);
		static string_type CastToString(unsigned __int64 i);
		static string_type CastToString(double d);
		static string_type CastToString(const string_type& s);
		static string_type CastToString(bool b);
		static string_type CastToString(DateTime dt);
		static string_type CastToString(Duration dur);
		static string_type CastToString(DayTimeDuration dt);
		static string_type CastToString(YearMonthDuration dur);
		static string_type CastToString(const std::vector<unsigned char>& v);

		static string_type FormatBase64(const std::vector<unsigned char>& s);

		enum DateTimeFormat
		{
			/* Format as schema dateTime */
			DateTimeFormat_W3_dateTime,

			/* Format as schema date */
			DateTimeFormat_W3_date,

			/* Format as schema time */
			DateTimeFormat_W3_time,

			/* Format as schema gYear */
			DateTimeFormat_W3_gYear,

			/* Format as schema gYearMonth */
			DateTimeFormat_W3_gYearMonth,

			/* Format as schema gMonth */
			DateTimeFormat_W3_gMonth,

			/* Format as schema gMonthDay */
			DateTimeFormat_W3_gMonthDay,

			/* Format as schema gDay */
			DateTimeFormat_W3_gDay,

			/* Format as standard DateTime "YYYY-MM-DD HH:MM:SS" */
			DateTimeFormat_S_DateTime,

			/* Format as number of seconds since epoch */
			DateTimeFormat_S_Seconds,

			/* Format as number of days since epoch */
			DateTimeFormat_S_Days,
		};

		static string_type CastToString(const DateTime& dt, DateTimeFormat format);
		static DateTime CastToDateTime(const DateTime& dt, DateTimeFormat format);

		static DateTime CastToDateTime(const string_type& s);
		static Duration CastToDuration(const string_type& s);
		static YearMonthDuration CastToYearMonthDuration(const string_type& s);
		static DayTimeDuration CastToDayTimeDuration(const string_type& s);

		static DateTime CastToDateTime(const DateTime& s);
		static Duration CastToDuration(const Duration& s);
		static YearMonthDuration CastToYearMonthDuration(const YearMonthDuration& s);
		static DayTimeDuration CastToDayTimeDuration(const DayTimeDuration& s);

		static bool CastToBool(bool b);
		static bool CastToBool(int i);
		static bool CastToBool(unsigned i);
		static bool CastToBool(__int64 i);
		static bool CastToBool(unsigned __int64 i);
		static bool CastToBool(double d);
		static bool CastToBool(const string_type& s);

		static bool CastToBool(const bool* v);
		static int CastToInt(const int* v);
		static unsigned CastToUInt(const unsigned* v);
		static __int64 CastToInt64(const __int64* v);
		static unsigned __int64 CastToUInt64(const unsigned __int64* v);
		static string_type CastToString(const string_type* v);
		static DateTime CastToDateTime(const DateTime* v);
		static Duration CastToDuration(const Duration* v);
		static double CastToDouble(const double* v);

		static std::vector<unsigned char> CastToBinary(const std::vector<unsigned char>& v);

		// helper methods for various formatters
		static void FormatNumber(string_type& result, unsigned value, unsigned minDigits);
		static void FormatTimezone(string_type& result, short value);
		static void FormatFraction(string_type& result, unsigned value, unsigned precision);
		static bool IsNumber(const string_type& str);

		static int* Box(int);
		static bool* Box(bool);
		static unsigned* Box(unsigned);
		static __int64* Box(__int64);
		static unsigned __int64* Box(unsigned __int64);
		static string_type* Box(const string_type&);
		static DateTime* Box(const DateTime&);
		static Duration* Box(const Duration&);
		static double* Box(double);

		static int* Box(int*);
		static bool* Box(bool*);
		static unsigned* Box(unsigned*);
		static __int64* Box(__int64*);
		static unsigned __int64* Box(unsigned __int64*);
		static string_type* Box(string_type*);
		static DateTime* Box(DateTime*);
		static Duration* Box(Duration*);
		static double* Box(double*);

		static int Unbox(int*);
		static bool Unbox(bool*);
		static unsigned Unbox(unsigned*);
		static __int64 Unbox(__int64*);
		static unsigned __int64 Unbox(unsigned __int64*);
		static string_type Unbox(string_type*);
		static DateTime Unbox(DateTime*);
		static Duration Unbox(Duration*);
		static double Unbox(double*);
	};


}





namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  CSchemaType
//
////////////////////////////////////////////////////////////////////////

class  CSchemaTypeNumber;
class  CSchemaTypeCalendar;

class ALTOVA_DECLSPECIFIER CSchemaType : public CBaseObject
{
public:
	typedef enum {
		// numeric types
		k_bool,
		k_byte, 
		k_unsigned_byte,
		k_short,
		k_unsigned_short,
		k_int,
		k_unsigned_int,
		k_long,
		k_unsigned_long,
		k_float,
		k_double,
		k_decimal,
		// calendar types
		k_Duration,
		k_Time,
		k_Day,
		k_Month,
		k_MonthDay,
		k_Year,
		k_YearMonth,
		k_Date,
		k_DateTime,
		// else
		k_String,
		k_Base64Binary,
		k_HexBinary,
		// ----------
		k_count,
		k_unknown = -1
	} ETypes ;

	// Construction
	CSchemaType();

	enum { TYPE = k_unknown };

	enum EWhitespaceFacet {
		WHITESPACE_PRESERVE,
		WHITESPACE_REPLACE,
		WHITESPACE_COLLAPSE
	};

	// Accessors
	bool											IsNull() const						{ return m_bIsNull; }
	void											SetIsNull( bool bIsNull )			{ m_bIsNull = bIsNull; if( bIsNull ) m_bIsEmpty = true; }
	bool											IsEmpty() const						{ return m_bIsNull || m_bIsEmpty; }
	void											SetIsEmpty( bool bIsEmpty )			{ m_bIsEmpty = bIsEmpty; if( !bIsEmpty ) m_bIsNull = false; }

	static tstring normalize(CSchemaType::EWhitespaceFacet wf, const TCHAR* sz);
	
	// --------- Interface ----------
	// Operators
	virtual bool									ToBool() const						{ return !IsEmpty(); }	// like XPATH function boolean()
	virtual operator								tstring() const = 0;




	// Operations
	virtual void									Empty()								{ m_bIsNull = false; m_bIsEmpty = true; }
	virtual bool									Parse( const TCHAR* szValue );
	virtual CSchemaType&							Assign( const CSchemaType& rOther );

	virtual CSchemaTypeNumber*						GetSchemaTypeNumberPtr() const		{ return NULL; }
	virtual CSchemaTypeCalendar*					GetSchemaTypeCalendarPtr() const	{ return NULL; }

	// statics
	static const TCHAR*								SchemaType2String( ETypes eType );

	static bool										CompareEqual( const CSchemaType& rObj1, const CSchemaType& rObj2);
	static bool										CompareLess( const CSchemaType& rObj1, const CSchemaType& rObj2);

	static bool										CompareNotEqual( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return !CompareEqual(rObj1, rObj2); }
	static bool										CompareGreater( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return CompareLess(rObj2, rObj1); }
	static bool										CompareLessEqual( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return CompareLess(rObj1, rObj2) || CompareEqual(rObj1, rObj2); }
	static bool										CompareGreaterEqual( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return CompareLess(rObj2, rObj1) || CompareEqual(rObj1, rObj2); }
protected:


private:
	bool											m_bIsEmpty;	// indicates if text-content of element is empty
	bool											m_bIsNull;	// indicates if the element is existing
};

inline tostream& operator<<(tostream& os, CSchemaType& t)
{
	return os << ((tstring)t).c_str();
}

} // namespace altova



#endif // ALTOVA_SCHEMATYPES_H_INCLUDED
