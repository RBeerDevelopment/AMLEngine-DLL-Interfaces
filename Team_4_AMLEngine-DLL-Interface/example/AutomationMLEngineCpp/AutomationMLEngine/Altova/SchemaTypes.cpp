////////////////////////////////////////////////////////////////////////
//
// SchemaTypes.cpp
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "Altova.h"
#include "AltovaException.h"
#include "SchemaTypes.h"

#include <math.h>
#include "SchemaTypeNumber.h"
#include "SchemaTypeCalendar.h"
#include "SchemaTypeString.h"
#include "SchemaTypeBinary.h"

#include <algorithm>
#include <limits>

#include "exception.h"

#undef min
#undef max

#ifdef _WIN32

#if _MSC_VER <= 1200

// VC6 does not properly define numeric_limits for __int64 and unsigned __int64, so we do it here
namespace std
{
class numeric_limits<__int64> : public _Num_int_base
{
public:
	typedef __int64 _Ty;
	static _Ty (__cdecl min)() _THROW0()
	{return (_I64_MIN); }
	static _Ty (__cdecl max)() _THROW0()
	{return (_I64_MAX); }
	static _Ty __cdecl epsilon() _THROW0()
	{return (0); }
	static _Ty __cdecl round_error() _THROW0()
	{return (0); }
	static _Ty __cdecl denorm_min() _THROW0()
	{return (0); }
	static _Ty __cdecl infinity() _THROW0()
	{return (0); }
	static _Ty __cdecl quiet_NaN() _THROW0()
	{return (0); }
	static _Ty __cdecl signaling_NaN() _THROW0()
	{return (0); }
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (__int64) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (__int64) - 1)
		* 301L / 1000);
};

class numeric_limits<unsigned __int64> : public _Num_int_base
{
public:
	typedef unsigned __int64 _Ty;
	static _Ty (__cdecl min)() _THROW0()
	{return 0; }
	static _Ty (__cdecl max)() _THROW0()
	{return (_UI64_MAX); }
	static _Ty __cdecl epsilon() _THROW0()
	{return (0); }
	static _Ty __cdecl round_error() _THROW0()
	{return (0); }
	static _Ty __cdecl denorm_min() _THROW0()
	{return (0); }
	static _Ty __cdecl infinity() _THROW0()
	{return (0); }
	static _Ty __cdecl quiet_NaN() _THROW0()
	{return (0); }
	static _Ty __cdecl signaling_NaN() _THROW0()
	{return (0); }
	_STCONS(bool, is_signed, true);
	_STCONS(int, digits, CHAR_BIT * sizeof (unsigned __int64) - 1);
	_STCONS(int, digits10, (CHAR_BIT * sizeof (unsigned __int64) - 1)
		* 301L / 1000);
};
}

#endif  // end of VC6 specific code


#pragma warning(disable:4996)	// VC2005 deprecation

#endif // _WIN32


namespace altova
{
	static bool IsSchemaWhitespace(char_type v)
	{
		return (v == '\x9' || v == '\x20' || v == '\xa' || v == '\xd');
	}

	static string_type::const_iterator SkipWhitespace(string_type::const_iterator begin, const string_type::const_iterator& end)
	{
		while (begin != end)
		{
			string_type::value_type v = *begin;
			if (!IsSchemaWhitespace(v))
				break;
			++begin;
		}
		return begin;
	}

	static bool IsDigit(const string_type::const_iterator& x)
	{
		string_type::value_type v = *x;
		return v >= '\x30' && v <= '\x39';
	}

	static int GetNumericValue(const string_type::const_iterator& x)
	{
		string_type::value_type v = *x;
		return v - '\x30';
	}

	static string_type::const_iterator IgnoreFraction(string_type::const_iterator begin, const string_type::const_iterator& end)
	{
		if (begin == end)
			return begin;
		if (*begin != '.')
			return begin;
		++begin;
		while (begin != end && IsDigit(begin))
			++begin;
		return begin;
	}

	static string_type::const_iterator IgnoreExponent(string_type::const_iterator begin, const string_type::const_iterator& end)
	{
		if (begin == end)
			return begin;
		if (*begin != 'e' && *begin != 'E')
			return begin;
		++begin;
		if (begin != end && (*begin == '+' || *begin == '-'))
			++begin;
		while (begin != end && IsDigit(begin))
			++begin;
		return begin;
	}

	static bool IsEqualString(string_type::const_iterator begin, const string_type::const_iterator& end, const char_type* str)
	{
		while (begin != end && *str)
		{
			if (*begin != *str)
				return false;
			++begin;
			++str;
		}
		return SkipWhitespace(begin, end) == end;
	}

	struct TValueComponents
	{
		unsigned __int64 value;
		bool positive;
		string_type::const_iterator end;
		bool overflow;
	};

	static TValueComponents ParseIntCore(string_type::const_iterator first, const string_type::const_iterator& end)
	{
		TValueComponents result = { 0, true, first, false };
		if (first == end) 
			return result;

		if (*first == '+') { ++first; }
		else if (*first == '-') { result.positive = false; ++first; }
		
		while (first != end && IsDigit(first))
		{						
			if (result.value >= std::numeric_limits<unsigned __int64>::max() / 10 && GetNumericValue(first) > std::numeric_limits<unsigned __int64>::max() % 10)
				result.overflow = true;

			result.value = result.value * 10 + GetNumericValue(first);
			++first;
		}

		result.end = IgnoreFraction(first, end);
		return result;
	}

	bool CoreTypes::IsNumber(const string_type& str)
	{
		TValueComponents comp = ParseIntCore(SkipWhitespace(str.begin(), str.end()), str.end());
		return SkipWhitespace(IgnoreExponent(comp.end, str.end()), str.end()) == str.end();		
	}

	int CoreTypes::CastToInt(int i) 
	{ 
		return i; 
	}

	int CoreTypes::CastToInt(unsigned int i) 
	{ 
		if (i > (unsigned) std::numeric_limits<int>::max()) 
			throw altova::OutOfRangeException(_T("unsignedInt"), _T("int"), CastToString(i));
		return (int)i; 
	}

	int CoreTypes::CastToInt(double d) 
	{ 
		if (d < std::numeric_limits<int>::min() || d > std::numeric_limits<int>::max())
			throw altova::OutOfRangeException(_T("double"), _T("int"), CastToString(d));
		return (int)d; 
	}
	


	int CoreTypes::CastToInt(const string_type& s) 
	{ 
		// parse according to schema rules.
		string_type::const_iterator first = SkipWhitespace(s.begin(), s.end());
		TValueComponents value = ParseIntCore(first, s.end());

		if (SkipWhitespace(value.end, s.end()) != s.end())
			throw altova::StringParseException(_T("int"), s);

		if (value.positive)
		{
			if (value.overflow || value.value > (unsigned __int64)std::numeric_limits<int>::max())
				throw altova::OutOfRangeException(_T("string"), _T("int"), s);
			return (int)value.value;
		}
		else
		{
			if (value.overflow || value.value > (unsigned __int64)-std::numeric_limits<int>::min())
				throw altova::OutOfRangeException(_T("string"), _T("int"), s);
			return -(int)value.value;
		}
	}


	int CoreTypes::CastToInt(__int64 i) 
	{ 
		if (i < std::numeric_limits<int>::min() || i > std::numeric_limits<int>::max())
			throw altova::OutOfRangeException(_T("long"), _T("int"), CastToString(i));
		return (int)i; 
	}


	int CoreTypes::CastToInt(unsigned __int64 i) 
	{ 
		if (i > std::numeric_limits<int>::max())
			throw altova::OutOfRangeException(_T("unsignedLong"), _T("int"), CastToString(i));
		return (int)i; 
	}


	unsigned CoreTypes::CastToUInt(int i) 
	{ 
		if (i < 0)
			throw altova::OutOfRangeException(_T("int"), _T("unsignedInt"), CastToString(i));
		return (unsigned)i; 
	}


	unsigned CoreTypes::CastToUInt(unsigned int i) 
	{ 
		return i; 
	}


	unsigned CoreTypes::CastToUInt(double d) 
	{ 
		if (d < 0 || d > std::numeric_limits<unsigned>::max())
			throw altova::OutOfRangeException(_T("double"), _T("unsignedInt"), CastToString(d));
		return (unsigned)d; 
	}


	unsigned CoreTypes::CastToUInt(const string_type& s) 
	{ 
		// parse according to schema rules.
		string_type::const_iterator first = SkipWhitespace(s.begin(), s.end());
		TValueComponents value = ParseIntCore(first, s.end());

		if (SkipWhitespace(value.end, s.end()) != s.end())
			throw altova::StringParseException(_T("unsignedInt"), s);

		if (value.positive || value.value == 0)
		{
			if (value.overflow || value.value > (unsigned __int64)std::numeric_limits<unsigned>::max())
				throw altova::OutOfRangeException(_T("string"), _T("unsignedInt"), s);
			return (unsigned)value.value;
		}
		else
			throw altova::OutOfRangeException(_T("string"), _T("unsignedInt"), s);
	}

	
	unsigned CoreTypes::CastToUInt(__int64 i) 
	{ 
		if (i < 0 || i > std::numeric_limits<unsigned>::max())
			throw altova::OutOfRangeException(_T("long"), _T("unsignedInt"), CastToString(i));
		return (unsigned)i; 	
	}


	unsigned CoreTypes::CastToUInt(unsigned __int64 i) 
	{ 
		if (i > std::numeric_limits<unsigned>::max())
			throw altova::OutOfRangeException(_T("unsignedLong"), _T("unsignedInt"), CastToString(i));
		return (unsigned)i; 
	}


	__int64 CoreTypes::CastToInt64(int i) 
	{ 
		return i; 
	}


	__int64 CoreTypes::CastToInt64(unsigned int i) 
	{ 
		return i; 
	}


	__int64 CoreTypes::CastToInt64(double d) 
	{ 
		if (d < std::numeric_limits<__int64>::min() || d > std::numeric_limits<__int64>::max())
			throw altova::OutOfRangeException(_T("double"), _T("long"), CastToString(d));
		
		return (__int64)d; 
	}


	__int64 CoreTypes::CastToInt64(const string_type& s) 
	{
		// parse according to schema rules.
		string_type::const_iterator first = SkipWhitespace(s.begin(), s.end());
		TValueComponents value = ParseIntCore(first, s.end());

		if (SkipWhitespace(value.end, s.end()) != s.end())
			throw altova::StringParseException(_T("long"), s);

		if (value.positive)
		{
			if (value.overflow || value.value > (unsigned __int64)std::numeric_limits<__int64>::max())
				throw altova::OutOfRangeException(_T("string"), _T("long"), s);
			return (__int64)value.value;
		}
		else
		{
			if (value.overflow || value.value > (unsigned __int64)-std::numeric_limits<__int64>::min())
				throw altova::OutOfRangeException(_T("string"), _T("long"), s);
			return -(__int64)value.value;
		}
	}


	__int64 CoreTypes::CastToInt64(__int64 i) 
	{ 
		return i; 
	}


	__int64 CoreTypes::CastToInt64(unsigned __int64 i) 
	{ 
		if (i > (unsigned __int64) std::numeric_limits<__int64>::max())
			throw altova::OutOfRangeException(_T("unsignedLong"), _T("long"), CastToString(i));
		return (__int64)i; 
	}

	unsigned __int64 CoreTypes::CastToUInt64(int i) 
	{ 
		return (unsigned __int64)i; 
	}


	unsigned __int64 CoreTypes::CastToUInt64(unsigned int i) 
	{ 
		return i; 
	}


	unsigned __int64 CoreTypes::CastToUInt64(double d) 
	{ 
		if (d < 0 || d > CastToDouble(std::numeric_limits<unsigned __int64>::max())) 
			throw altova::OutOfRangeException(_T("double"), _T("unsignedLong"), CastToString(d));
		return (unsigned __int64)d; 	
	}


	unsigned __int64 CoreTypes::CastToUInt64(const string_type& s) 
	{ 
		// parse according to schema rules.
		string_type::const_iterator first = SkipWhitespace(s.begin(), s.end());
		TValueComponents value = ParseIntCore(first, s.end());

		if (SkipWhitespace(value.end, s.end()) != s.end())
			throw altova::StringParseException(_T("unsignedLong"), s);

		if (!value.overflow || value.positive || value.value == 0)
			return value.value;
		else
			throw altova::OutOfRangeException(_T("string"), _T("unsignedLong"), s);
	}


	unsigned __int64 CoreTypes::CastToUInt64(__int64 i) 
	{ 
		if (i < 0)
			throw altova::OutOfRangeException(_T("long"), _T("unsignedLong"), CastToString(i));
		return (unsigned __int64)i; 
	}


	unsigned __int64 CoreTypes::CastToUInt64(unsigned __int64 i) 
	{
		return i; 
	}


	double CoreTypes::CastToDouble(int i) 
	{ 
		return i; 
	}
	
	
	double CoreTypes::CastToDouble(unsigned i) 
	{ 
		return i; 
	}


	double CoreTypes::CastToDouble(__int64 i) 
	{ 
		return (double)i; 
	}

	double CoreTypes::CastToDouble(unsigned __int64 i) 
	{ 
#if defined(_MSC_VER) && _MSC_VER <= 1200
		double d = (unsigned)i;
		d = d + ((unsigned)(i >> 32)) * 4294967296.0;
		return d;
#else
		return (double)i; 
#endif
	}


	double CoreTypes::CastToDouble(double d) 
	{ 
		return d; 
	}


	double CoreTypes::CastToDouble(const string_type& s) 
	{
		// parse according to schema rules.
		string_type::const_iterator first = SkipWhitespace(s.begin(), s.end());
		if (first == s.end()) 
			return 0;

		if (IsEqualString(first, s.end(), _T("NaN")))
			return std::numeric_limits<double>::quiet_NaN();

		bool positive = true;
		if (*first == '+') { ++first; }
		else if (*first == '-') { positive = false; ++first; }

		if (IsEqualString(first, s.end(), _T("INF")))
			return positive ? std::numeric_limits<double>::infinity() : -std::numeric_limits<double>::infinity();

		double value = 0;
		while (first != s.end() && IsDigit(first))
		{						
			value = value * 10 + GetNumericValue(first);
			++first;
		}

		int exponent = 0;

		if (first != s.end() && *first == '.')
		{			
			++first;
			int digits = 0;

			string_type::const_iterator end = first;

			// ignore trailing zeros
			while (end != s.end() && IsDigit(end))
				++end;
			while (*(end - 1) == _T('0'))
				--end;

			while (first != end && digits < 17 && IsDigit(first))
			{				
				value = value * 10 + GetNumericValue(first);
				++first;
				--exponent;
				++digits;
			}			

			// skip zeroes
			while (first != s.end() && IsDigit(first))
				++first;			
		}

		if (first != s.end() && (*first == 'e' || *first == 'E'))
		{
			++first;

			TValueComponents v = ParseIntCore(first, s.end());
			first = v.end;
			exponent += v.positive ? (int)v.value : -(int)v.value;

		}

		if (exponent < 0)
		{
			double divisor = 10;
			for (unsigned u = 0; u != 16; ++u)
			{
				if (-exponent & (1 << u))
					value /= divisor;
				divisor *= divisor;
			}
		}
		else
		{
			double factor = 10;
			for (unsigned u = 0; u != 16; ++u)
			{
				if (exponent & (1 << u))
					value *= factor;
				factor *= factor;
			}
		}

		if (SkipWhitespace(first, s.end()) != s.end())
			throw altova::StringParseException(_T("double"), s);

		return positive ? value : -value;		
	}


	string_type CoreTypes::CastToString(double d) 
	{ 
		double origd = d;
		// according to IEEE this is valid:
		if (d != d)
			return _T("NaN");

		if (d <= -std::numeric_limits<double>::infinity())
			return _T("-INF");

		if (d >= std::numeric_limits<double>::infinity())
			return _T("INF");

		if (d == 0)	// exact zero
			return _T("0");

		string_type result;

		// Typically double is used for decimal, therefore no exponent shall be written.
		const int MinDigits = 14;	// emit at this many digits for double
		bool negative = false;
		if (d < 0)
		{
			negative = true;
			d = -d;
		}

		// scale number (inefficient variant)

		double exponent = log10(d);		
		int scale = (int)floor(exponent);
		scale -= MinDigits;

		static double factors[] = 
		{
			1e1,
			1e2,
			1e4,
			1e8,
			1e16,
			1e32,
			1e64,
			1e128,
			1e256,
		};

		if (scale > 0)
		{
			double factor = 10;
			for (unsigned u = 0; u != 9; ++u)
			{
				if (scale & (1 << u))
					d /= factors[u];//factor;
				//factor *= factor;
			}
		}
		else
		{
			double factor = 10;
			for (unsigned u = 0; u != 9; ++u)
			{
				if (-scale & (1 << u))
					d *= factors[u];
				factor *= factor;
			}
		}		

		scale += MinDigits;
		__int64 mantissa = (__int64) floor(d + 0.5);
		result = CastToString(mantissa);

		// now place comma in right position, that is scale places from the right.
		if (scale >= MinDigits)
		{
			result.append(scale - MinDigits + 1, _T('0'));
		}
		if (scale < 0)
		{
			std::reverse(result.begin(), result.end());
			result.append(-scale, _T('0'));
			std::reverse(result.begin(), result.end());
			scale = 0;
		}

		result.insert(scale + 1, 1, _T('.'));
		if (negative)
			result.insert((string_type::size_type)0, 1, _T('-'));

		while (true)
		{
			// now remove trailing zeros
			while (result.at(result.size()-1) == _T('0'))
				result.erase(result.size()-1, 1);

			if (result.at(result.size()-1) == _T('.'))
			{
				result.erase(result.size()-1, 1);
				break;	// can't remove any more digits
			}

			string_type temp = result.substr(0, result.size() - 1);


			if (CastToDouble(temp) != origd)
				break;
			result = temp;
		}

		return result;
	}


	string_type CoreTypes::FormatBase64(const std::vector<unsigned char>& v)
	{
		string_type result;
		static char_type EncodingTable[] = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
		unsigned counter = 0;
		for (std::vector<unsigned char>::const_iterator it = v.begin(); it != v.end(); )
		{
			unsigned char b1 = *it++;
			result.append(1, EncodingTable[b1 >> 2]);
			if (it != v.end())
			{
				unsigned char b2 = *it++;
				result.append(1, EncodingTable[((b1 & 3) << 4) | (b2 >> 4)]);

				if (it != v.end())
				{
					unsigned char b3 = *it++;
					result.append(1, EncodingTable[((b2 & 15) << 2) | (b3 >> 6)]);
					result.append(1, EncodingTable[(b3 & 63)]);					
					counter = 0;
					if (counter == 76)
					{
						result.append(1, (char_type)0xa);
						counter = 0;
					}
				}
				else
				{
					result.append(1, EncodingTable[((b2 & 15) << 2)]);
					result.append(1, _T('='));
				}
			}
			else
			{
				result.append(1, EncodingTable[((b1 & 3) << 4)]);				
				result.append(1, _T('='));
				result.append(1, _T('='));
			}
		}
		return result;
	}

	string_type CoreTypes::CastToString(const std::vector<unsigned char>& v)
	{
		return FormatBase64(v);
	}


#if defined(UNICODE) || defined(_UNICODE)
string_type CoreTypes::CastToString(int i) { wchar_t buf[40]; return _itow(i, buf, 10); return buf;  }
string_type CoreTypes::CastToString(unsigned int i) { wchar_t buf[40]; return _itow(i, buf, 10);  return buf; }
string_type CoreTypes::CastToString(__int64 i) { wchar_t buf[40]; return _i64tow(i, buf, 10); return buf; }
string_type CoreTypes::CastToString(unsigned __int64 i) { wchar_t buf[40]; return _i64tow(i, buf, 10); return buf; }
string_type CoreTypes::CastToString(const string_type& s) { return s; }
string_type CoreTypes::CastToString(bool b) { return b ? L"true" : L"false"; }
#else
string_type CoreTypes::CastToString(int i) { char buf[40]; return itoa(i, buf, 10);  }
string_type CoreTypes::CastToString(unsigned int i) { char buf[40]; return itoa(i, buf, 10);  }
string_type CoreTypes::CastToString(__int64 i) { char buf[40]; return _i64toa(i, buf, 10); }
string_type CoreTypes::CastToString(unsigned __int64 i) { char buf[40]; return _i64toa(i, buf, 10); }
string_type CoreTypes::CastToString(const string_type& s) { return s; }
string_type CoreTypes::CastToString(bool b) { return b ? "true" : "false"; }
#endif

bool CoreTypes::CastToBool(bool b) { return b; }
bool CoreTypes::CastToBool(int i) { return i != 0; }
bool CoreTypes::CastToBool(unsigned i) { return i != 0; }
bool CoreTypes::CastToBool(__int64 i) { return i != 0; }
bool CoreTypes::CastToBool(unsigned __int64 i) { return i != 0; }
bool CoreTypes::CastToBool(double d) { return d != 0; }
bool CoreTypes::CastToBool(const string_type& s) { if (s == _T("false") || s == _T("") || s == _T("0")) return false; return true; }

std::vector<unsigned char> CoreTypes::CastToBinary(const std::vector<unsigned char>& v) { return v; }

void CoreTypes::FormatNumber(string_type& target, unsigned value, unsigned minDigits)
{
	char_type temp[32];
	char_type* p = temp;
	while(value != 0)
	{
		*p++ = (value % 10) + '0';
		value /= 10;
	}
	while (p - temp < (int)minDigits)
		*p++ = '0';
	while (p != temp)
	{
		target.append(1, *(p - 1));
		--p;
	}
}

void CoreTypes::FormatTimezone(string_type& result, short value)
{
	if (value == 0)
		result.append(1, _T('Z'));
	else
	{
		if (value< 0)
		{
			result.append(1, _T('-'));
			value = -value;
		}
		else
		{
			result.append(1, _T('+'));
		}
		FormatNumber(result, value / 60, 2);
		result.append(1, _T(':'));
		FormatNumber(result, value % 60, 2);
	}
}

void CoreTypes::FormatFraction(string_type& result, unsigned value, unsigned precision)
{
	if (value != 0)
	{
		result.append(1, _T('.'));
		FormatNumber(result, value, precision);
		string_type::size_type s = result.size();
		while (result.at(s - 1) == '0')
			s -= 1;
		result.erase(s);
	}
}


string_type CoreTypes::CastToString(const altova::DateTime& dt, DateTimeFormat format)
{
	string_type result;

	int year, month, day;
	DateTime::GetDateFromTimeValue(dt.Value(), year, month, day);
	__int64 value = dt.Value();
	__int64 intraday = value % (86400 * altova::TicksPerSecond);
	if (intraday < 0) intraday += (86400 * altova::TicksPerSecond);
	unsigned fraction = (unsigned)(intraday % altova::TicksPerSecond);
	intraday /= altova::TicksPerSecond;
	unsigned second = (unsigned)(intraday % 60);
	intraday /= 60;
	unsigned minute = (unsigned)(intraday % 60);
	intraday /= 60;
	unsigned hour = (unsigned)intraday;

	// print date part
	switch (format)
	{
	case DateTimeFormat_W3_dateTime:
	case DateTimeFormat_W3_date:
	case DateTimeFormat_S_DateTime:		
		if (year < 0)
		{
			result.append(1, _T('-'));
			year = -year;
		}
		FormatNumber(result, year, 4);
		result.append(1, _T('-'));
		FormatNumber(result, month, 2);
		result.append(1, _T('-'));
		FormatNumber(result, day, 2);
		break;
	}

	// print a separator.
	switch (format)
	{
	case DateTimeFormat_W3_dateTime:
		result.append(1, _T('T'));
		break;
	case DateTimeFormat_S_DateTime:
		result.append(1, _T(' '));
		break;
	}

	// print the remainder
	switch (format)
	{
	case DateTimeFormat_W3_dateTime:
	case DateTimeFormat_S_DateTime:
	case DateTimeFormat_W3_time:
		FormatNumber(result, hour, 2);
		result.append(1, _T(':'));
		FormatNumber(result, minute, 2);
		result.append(1, _T(':'));
		FormatNumber(result, second, 2);
		FormatFraction(result, fraction, 7);
		break;

	case DateTimeFormat_W3_gYear:
		if (year < 0)
		{
			result.append(1, _T('-'));
			year = -year;
		}
		FormatNumber(result, year, 4);
		break;

	case DateTimeFormat_W3_gYearMonth:
		if (year < 0)
		{
			result.append(1, _T('-'));
			year = -year;
		}
		FormatNumber(result, year, 4);
		result.append(1, _T('-'));
		FormatNumber(result, month, 2);
		break;

	case DateTimeFormat_W3_gMonth:
		result.append(2, _T('-'));
		FormatNumber(result, month, 2);
		break;

	case DateTimeFormat_W3_gMonthDay:
		result.append(2, _T('-'));
		FormatNumber(result, month, 2);
		result.append(1, _T('-'));
		FormatNumber(result, day, 2);
		break;

	case DateTimeFormat_W3_gDay:
		result.append(3, _T('-'));
		FormatNumber(result, day, 2);
		break;

	case DateTimeFormat_S_Seconds:
		if (value < 0)
		{
			result.append(1, _T('-'));
			value = -value;
		}
		FormatNumber(result, unsigned(value / altova::TicksPerSecond), 1);
		FormatFraction(result, unsigned(value % altova::TicksPerSecond), 7);
		break;

	case DateTimeFormat_S_Days:
		if (value < 0)
		{
			result.append(1, _T('-'));
			value = -value;
		}
		FormatNumber(result, unsigned(value / (86400 * altova::TicksPerSecond)), 1);
		FormatFraction(result, unsigned(value % (86400 * altova::TicksPerSecond) / 86400), 7);
		break;
	}

	if (dt.HasTimezone())
		FormatTimezone(result, dt.Timezone());

	return result;
}


string_type CoreTypes::CastToString(altova::DateTime dt)
{
	return CastToString(dt, DateTimeFormat_W3_dateTime);
}


string_type CoreTypes::CastToString(altova::Duration dur)
{
	string_type result;
	if (dur.IsNegative() && dur.IsPositive())
		throw altova::ValueNotRepresentableException(_T("duration"), 
			_T("Sign of year month part differs from sign of day time part."));
	
	if (dur.IsNegative())
	{
		result += _T("-");
		dur = -dur;
	}

	result += _T("P");
	if (dur.Years())
		result += CastToString(dur.Years()) + _T("Y");
	if (dur.Months())
		result += CastToString(dur.Months()) + _T("M");
	if (dur.Days())
		result += CastToString(dur.Days()) + _T("D");

	if (dur.Hours() || dur.Minutes() || dur.Seconds())
		result += _T("T");
	if (dur.Hours())
		result += CastToString(dur.Hours()) + _T("H");
	if (dur.Minutes())
		result += CastToString(dur.Minutes()) + _T("M");
	if (dur.Seconds())
		result += CastToString(dur.Seconds()) + _T("S");

	if (result[result.size()-1] == 'P')
		result += _T("T0S");

	return result;
}

string_type CoreTypes::CastToString(altova::DayTimeDuration dur)
{
	string_type result;
	if (dur.IsNegative())
	{
		result += _T("-");
		dur = -dur;
	}

	result += _T("P");
	if (dur.Days())
		result += CastToString(dur.Days()) + _T("D");

	if (dur.Hours() || dur.Minutes() || dur.Seconds())
		result += _T("T");
	if (dur.Hours())
		result += CastToString(dur.Hours()) + _T("H");
	if (dur.Minutes())
		result += CastToString(dur.Minutes()) + _T("M");
	if (dur.Seconds())
		result += CastToString(dur.Seconds()) + _T("S");

	if (result[result.size()-1] == 'P')
		result += _T("T0S");

	return result;
}

string_type CoreTypes::CastToString(altova::YearMonthDuration dur)
{
	string_type result;

	if (dur.IsNegative())
	{
		result += _T("-");
		dur = -dur;
	}

	result += _T("P");
	if (dur.Years())
		result += CastToString(dur.Years()) + _T("Y");
	if (dur.Months())
		result += CastToString(dur.Months()) + _T("M");

	if (result[result.size()-1] == 'P')
		result += _T("0M");
	return result;
}


enum ParseDateTimeFlags
{
	ParseDateTimeFlag_RequireYear = (1 << 0),
	ParseDateTimeFlag_RequireMonth = (1 << 1),
	ParseDateTimeFlag_RequireDay = (1 << 2),
	ParseDateTimeFlag_RequireDate = ParseDateTimeFlag_RequireYear|ParseDateTimeFlag_RequireMonth|ParseDateTimeFlag_RequireDay,
	ParseDateTimeFlag_RequireTime = (1 << 3),
	ParseDateTimeFlag_AllowYear = (1 << 4),
	ParseDateTimeFlag_AllowMonth = (1 << 5),
	ParseDateTimeFlag_AllowDay = (1 << 6),
	ParseDateTimeFlag_AllowDate = ParseDateTimeFlag_AllowYear|ParseDateTimeFlag_AllowMonth|ParseDateTimeFlag_AllowDay,
	ParseDateTimeFlag_AllowTime = (1 << 7),
};


// isdigit depends on locale, which we do not want
inline bool IsSchemaDigit(char_type c)
{
	return c >= '0' && c <= '9';
}

inline unsigned GetSchemaDigitValue(char_type c)
{
	return c - '0';
}

struct DateTimeParseState
{
	string_type::size_type pos;
	int year;
	unsigned month, day, hour, minute, second, fraction;
	int timezone;
	unsigned value;
};


void SkipWhitespace(const string_type& input, DateTimeParseState& state)
{
	while (state.pos != input.size()) 
	{ 
		char_type c = input.at(state.pos);
		if (c != (char_type)0x20 && c != (char_type)0x09 && 
			c != (char_type)0x0a && c != (char_type)0x0d)
			break;
		state.pos += 1;
	}
}

bool Read2DigitNumber(const string_type& input, DateTimeParseState& state)
{
	if (state.pos == input.size())
		return false;
	char_type c = input.at(state.pos);
	if (!IsSchemaDigit(c))
		return false;
	state.value = GetSchemaDigitValue(c);

	if (++state.pos == input.size())
		return false;
	c = input.at(state.pos);
	if (!IsSchemaDigit(c))
		return false;
	state.value = state.value * 10 + GetSchemaDigitValue(c);
	++state.pos;
	return true;
}

bool ReadNumber(const string_type& input, DateTimeParseState& state)
{
	if (state.pos == input.size())
		return false;
	char_type c = input.at(state.pos);
	if (!IsSchemaDigit(c))
		return false;
	state.value = GetSchemaDigitValue(c);
	++state.pos;
	while (state.pos != input.size())
	{
		c = input.at(state.pos);
		if (!IsSchemaDigit(c))
			break;
		state.value = state.value * 10 + GetSchemaDigitValue(c);
		++state.pos;
	}
	return true;
}

bool ReadFraction(const string_type& input, DateTimeParseState& state)
{
	state.fraction = 0;
	if (state.pos == input.size())
		return true;

	char_type c = input.at(state.pos);
	if (c != '.')
		return true;	// no fraction, but it is optional -> ok
	if (++state.pos == input.size())
		return false;	// at least one digit must follow
	if (!IsSchemaDigit(input.at(state.pos)))
		return false;

	// now examine 7 digits (governed by TicksPerSecond actually)	
	for (unsigned u = 0; u != 7; ++u)
	{
		state.fraction = state.fraction * 10;
		if (state.pos != input.size())
		{
			char_type c = input.at(state.pos);
			if (IsSchemaDigit(c))
			{
				state.fraction += GetSchemaDigitValue(c);
				++state.pos;
			}
		}
	}

	// if available, examine the next digit if >= 5
	if (state.pos != input.size())
	{
		char_type c = input.at(state.pos);
		if (IsSchemaDigit(c))
		{
			if (GetSchemaDigitValue(c) >= 5)
				state.fraction += 1;
			++state.pos;
		}
		// ignore any further digits
		while (state.pos != input.size())
		{
			if (!IsSchemaDigit(input.at(state.pos)))
				break;
			++state.pos;
		}
	}

	return true;
}


bool ReadTime(const string_type& input, DateTimeParseState& state)
{
	if (!Read2DigitNumber(input, state))
		return false;
	if (state.value > 24)
		return false;
	state.hour = state.value;
	if (state.pos == input.size())
		return false;
	if (input.at(state.pos) != ':')
		return false;
	++state.pos;
	if (!Read2DigitNumber(input, state))
		return false;
	if (state.value >= 60 || (state.hour == 24 && state.value != 0))		
		return false;
	state.minute = state.value;
	if (state.pos == input.size())
		return false;
	if (input.at(state.pos) != ':')
		return false;
	++state.pos;
	if (!Read2DigitNumber(input, state))
		return false;
	if (state.value >= 60 || (state.hour == 24 && state.value != 0))		
		return false;
	state.second = state.value;
	if (!ReadFraction(input, state))
		return false;
	return true;
}

bool ReadYear(const string_type& input, DateTimeParseState& state)
{
	// read 4 digits
	state.year = 0;
	for (unsigned u = 0; u != 4; ++u)
	{
		if (state.pos == input.size())
			return false;
		char_type c = input.at(state.pos);
		if (!IsSchemaDigit(c))
			return false;
		state.year = state.year * 10 + GetSchemaDigitValue(c);
		++state.pos;
	}

	if (state.year >= 1000)
	{
		// read more digits in this case (otherwise we leave the digits and the parser will fail)
		while (state.pos != input.size())
		{
			char_type c = input.at(state.pos);
			if (!IsSchemaDigit(c))
				break;
			state.year = state.year * 10 + GetSchemaDigitValue(c);
			++state.pos;
		}		
	}
	return true;
}


bool TryParseDateTime(const string_type& input, unsigned formatFlags, altova::DateTime& value)
{
	DateTimeParseState state;

	if ((formatFlags & ParseDateTimeFlag_RequireYear) != 0)
		formatFlags |= ParseDateTimeFlag_AllowYear;
	if ((formatFlags & ParseDateTimeFlag_RequireMonth) != 0)
		formatFlags |= ParseDateTimeFlag_AllowMonth;
	if ((formatFlags & ParseDateTimeFlag_RequireDay) != 0)
		formatFlags |= ParseDateTimeFlag_AllowDay;
	if ((formatFlags & ParseDateTimeFlag_RequireTime) != 0)
		formatFlags |= ParseDateTimeFlag_AllowTime;

	state.pos = 0;
	state.year = state.month = state.day = 1;
	state.hour = state.minute = state.second = state.fraction = state.timezone = 0;

	SkipWhitespace(input, state);
	if (state.pos == input.size())
		return false;	// not a valid dateTime

	// if string is a time string, the 3rd character is a ':', otherwise it is not. 
	if (state.pos + 3 > input.size())
		return false;	// no known format of this kind

	if (input.at(state.pos + 2) == ':')
	{
		// time only 
		if ((formatFlags & ParseDateTimeFlag_AllowTime) == 0 ||
			(formatFlags & ParseDateTimeFlag_RequireDate) != 0)
			return false;

		state.year = state.month = state.day = 1;
		if (!ReadTime(input, state))
			return false;
	}
	else
	{
		// date possibly followed by time
		if ((formatFlags & ParseDateTimeFlag_AllowDate) == 0)
			return false;

		// this must be present (ensured above)
		bool positive = true;
		if (input.at(state.pos) == '-')
		{
			positive = false;
			++state.pos;
		}

		// next char is either '-' for no year at all, or a digit
		if (state.pos == input.size())
			return false;
		if (input.at(state.pos) != '-')
		{
			if ((formatFlags & ParseDateTimeFlag_AllowYear) == 0)
				return false;
			if (!ReadYear(input, state))
				return false;		

			if (!positive)
				state.year = -state.year;
		}
		else
		{
			if ((formatFlags & ParseDateTimeFlag_RequireYear) != 0)
				return false;
			formatFlags &= ~ParseDateTimeFlag_AllowTime;	// disallow time
			state.year = 4;
		}

		// now care must be taken: the next character can be '-', but this may be part of the timezone
		if (state.pos != input.size() && input.at(state.pos) == '-')
		{
			// if timezone, then '-HH:MM'
			if (state.pos + 3 >= input.size() || input.at(state.pos + 3) != ':')
			{
				// a month, maybe.
				++state.pos;	// skip '-' anyways.
				if (state.pos == input.size())	// ok, that is odd
					return false;

				if (input.at(state.pos) != '-')	
				{
					// month
					if ((formatFlags & ParseDateTimeFlag_AllowMonth) == 0)
						return false;	// not allowed
					if (!Read2DigitNumber(input, state))
						return false;
					state.month = state.value;
				}
				else
				{
					if ((formatFlags & ParseDateTimeFlag_RequireMonth) != 0)
						return false;	// was required
					formatFlags &= ~ParseDateTimeFlag_AllowTime;	// disallow time
					state.month = 1;
				}
			}
			else
			{
				if ((formatFlags & ParseDateTimeFlag_RequireMonth) != 0)
					return false;	// was required
				formatFlags &= ~ParseDateTimeFlag_AllowTime;
			}
		}
		else
		{
			if ((formatFlags & ParseDateTimeFlag_RequireMonth) != 0)
				return false;	// was required
			formatFlags &= ~ParseDateTimeFlag_AllowTime;
		}

		// now care must be taken: the next character can be '-', but this may be part of the timezone
		if (state.pos != input.size() && input.at(state.pos) == '-')
		{
			// if timezone, then '-HH:MM'
			if (state.pos + 3 >= input.size() || input.at(state.pos + 3) != ':')
			{
				// a day, maybe.
				++state.pos;	// skip '-' anyways.
				if (state.pos == input.size())	// ok, that is odd
					return false;

				// day
				if ((formatFlags & ParseDateTimeFlag_AllowDay) == 0)
					return false;	// not allowed
				if (!Read2DigitNumber(input, state))
					return false;
				state.day = state.value;
			}
			else
			{
				if ((formatFlags & ParseDateTimeFlag_RequireDay) != 0)
					return false;	// not allowed
				formatFlags &= ~ParseDateTimeFlag_AllowTime;
			}
		}
		else
		{
			if ((formatFlags & ParseDateTimeFlag_RequireDay) != 0)
				return false;	// not allowed
			formatFlags &= ~ParseDateTimeFlag_AllowTime;
		}

		if (state.pos != input.size() && input.at(state.pos) == 'T')
		{
			// time part 
			if ((formatFlags & ParseDateTimeFlag_AllowTime) == 0)
				return false; 
			++state.pos;
			if (!ReadTime(input, state))
				return false;
		}
		else
		{
			if ((formatFlags & ParseDateTimeFlag_RequireTime) != 0)
				return false;
		}
	}

	// timezone
	if (state.pos != input.size())
	{
		char_type c = input.at(state.pos);
		if (c == '+' || c == '-')
		{
			bool positiveOffset = c == '+';
			++state.pos;
			if (!Read2DigitNumber(input, state))
				return false;
			if (state.value >= 24)
				return false;
			state.timezone = state.value * 60;
			if (state.pos == input.size())
				return false;
			if (input.at(state.pos) != ':')
				return false;
			++state.pos;
			if (!Read2DigitNumber(input, state))
				return false;
			if (state.value >= 60)
				return false;
			state.timezone += state.value;
			if (!positiveOffset)
				state.timezone = -state.timezone;
		}
		else if (c == 'Z')
		{
			++state.pos;
			state.timezone = 0;
		}		
	}
	else
		state.timezone = altova::DateTime::NO_TIMEZONE;

	SkipWhitespace(input, state);
	if (state.pos != input.size())
		return false;


	value = altova::DateTime(
		state.year, state.month, state.day, state.hour, state.minute, 
		state.second + (double)state.fraction / altova::TicksPerSecond, state.timezone);
	return true;
}





altova::DateTime CoreTypes::CastToDateTime(const string_type& s)
{
	altova::DateTime dt;
	if (!TryParseDateTime(s, ParseDateTimeFlag_AllowTime|ParseDateTimeFlag_AllowDate, dt))
		throw altova::StringParseException(_T("dateTime"), s);

	return dt;
}

altova::DateTime CoreTypes::CastToDateTime(const altova::DateTime& s, DateTimeFormat format)
{
	return CastToDateTime(s);
}


altova::Duration CoreTypes::CastToDuration(const string_type& s)
{
	bool positive = true;
	DateTimeParseState state;
	state.pos = 0;
	SkipWhitespace(s, state);
	if (state.pos == s.size())
		throw altova::StringParseException(_T("duration"), s);

	if (s.at(state.pos) == '-')
	{
		positive = false;
		if (++state.pos == s.size())
			throw altova::StringParseException(_T("duration"), s);
	}

	if (s.at(state.pos) != 'P')
		throw altova::StringParseException(_T("duration"), s);

	if (++state.pos == s.size())
		throw altova::StringParseException(_T("duration"), s);

	int ymvalue = 0;
	__int64 dtvalue = 0;

	bool number = ReadNumber(s, state);
	bool anyFound = false;
	if (number)	// try 'Y'
	{
		if (state.pos == s.size())
			throw altova::StringParseException(_T("duration"), s);
		if (s.at(state.pos) == 'Y')
		{
			anyFound = true;
			ymvalue += state.value * 12;
			++state.pos;
			number = ReadNumber(s, state);
		}
	}
	if (number) // try 'M'
	{
		if (state.pos == s.size())
			throw altova::StringParseException(_T("duration"), s);
		if (s.at(state.pos) == 'M')
		{
			anyFound = true;
			ymvalue += state.value;
			++state.pos;
			number = ReadNumber(s, state);
		}
	}
	if (number) // try 'D'
	{
		if (state.pos == s.size())
			throw altova::StringParseException(_T("duration"), s);
		if (s.at(state.pos) == 'D')
		{
			anyFound = true;
			dtvalue += state.value * 86400 * TicksPerSecond;
			++state.pos;			
		}
	}
	if (state.pos != s.size() && s.at(state.pos) == 'T')
	{
		// time part
		++state.pos;
		number = ReadNumber(s, state);
		if (!number) 
			throw altova::StringParseException(_T("duration"), s);
		if (state.pos == s.size())
			throw altova::StringParseException(_T("duration"), s);
		if (s.at(state.pos) == 'H')
		{
			anyFound = true;
			dtvalue += state.value * 3600 * TicksPerSecond;
			++state.pos;
			number = ReadNumber(s, state);
		}
		if (number)
		{
			if (state.pos == s.size())
				throw altova::StringParseException(_T("duration"), s);
			if (s.at(state.pos) == 'M')
			{
				anyFound = true;
				dtvalue += state.value * 60 * TicksPerSecond;
				++state.pos;
				number = ReadNumber(s, state);
			}
		}
		if (number)
		{
			if (state.pos == s.size())
				throw altova::StringParseException(_T("duration"), s);
			if (s.at(state.pos) == 'S')
			{
				anyFound = true;
				dtvalue += state.value * TicksPerSecond;
				++state.pos;				
			}
			else if (s.at(state.pos) == '.')
			{
				anyFound = true;
				dtvalue += state.value * TicksPerSecond;
				if (!ReadFraction(s, state))
					throw altova::StringParseException(_T("duration"), s);
				dtvalue += state.fraction;
				if (s.at(state.pos) != 'S')
					throw altova::StringParseException(_T("duration"), s);
				++state.pos;
			}
		}
	}

	SkipWhitespace(s, state);
	if (state.pos != s.size())
		throw altova::StringParseException(_T("duration"), s);

	if (!anyFound)
		throw altova::StringParseException(_T("duration"), s);

	return altova::Duration(altova::YearMonthDuration(positive ? ymvalue : -ymvalue), altova::DayTimeDuration(positive ? dtvalue : -dtvalue));
}

altova::YearMonthDuration CoreTypes::CastToYearMonthDuration(const string_type& s)
{
	CSchemaDuration dur;
	dur.Parse(s.c_str());
	return altova::YearMonthDuration(dur.GetValue().GetYearMonthValue());
}

altova::DayTimeDuration CoreTypes::CastToDayTimeDuration(const string_type& s)
{
	CSchemaDuration dur;
	dur.Parse(s.c_str());
	return altova::DayTimeDuration(dur.GetValue().GetDayTimeValue());
}

altova::DateTime CoreTypes::CastToDateTime(const altova::DateTime& s) { return s; }
altova::Duration CoreTypes::CastToDuration(const altova::Duration& s) { return s; }
altova::YearMonthDuration CoreTypes::CastToYearMonthDuration(const altova::YearMonthDuration& s) { return s; }
altova::DayTimeDuration CoreTypes::CastToDayTimeDuration(const altova::DayTimeDuration& s) { return s; }



bool CoreTypes::CastToBool(const bool* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

int CoreTypes::CastToInt(const int* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

unsigned CoreTypes::CastToUInt(const unsigned* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

__int64 CoreTypes::CastToInt64(const __int64* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

unsigned __int64 CoreTypes::CastToUInt64(const unsigned __int64* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

string_type CoreTypes::CastToString(const string_type* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

altova::DateTime CoreTypes::CastToDateTime(const altova::DateTime* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

altova::Duration CoreTypes::CastToDuration(const altova::Duration* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

double CoreTypes::CastToDouble(const double* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

int* CoreTypes::Box(int i)
{
	return new int(i);
}

bool* CoreTypes::Box(bool b)
{
	return new bool(b);
}

unsigned* CoreTypes::Box(unsigned u)
{
	return new unsigned(u);
}

__int64* CoreTypes::Box(__int64 i)
{
	return new __int64(i);
}

unsigned __int64* CoreTypes::Box(unsigned __int64 u)
{
	return new unsigned __int64(u);
}

string_type* CoreTypes::Box(const string_type& s)
{
	return new string_type(s);
}

altova::DateTime* CoreTypes::Box(const altova::DateTime& dt)
{
	return new altova::DateTime(dt);
}

altova::Duration* CoreTypes::Box(const altova::Duration& d)
{
	return new altova::Duration(d);
}

double* CoreTypes::Box(double d)
{
	return new double(d);
}


int* CoreTypes::Box(int* p)
{
	if (p == 0) return 0;
	return new int(*p);
}

bool* CoreTypes::Box(bool* p) 
{
	if (p == 0) return 0;
	return new bool(*p);
}

unsigned* CoreTypes::Box(unsigned* p)
{
	if (p == 0) return 0;
	return new unsigned(*p);
}

__int64* CoreTypes::Box(__int64* p)
{
	if (p == 0) return 0;
	return new __int64(*p);
}

unsigned __int64* CoreTypes::Box(unsigned __int64* p)
{
	if (p == 0) return 0;
	return new unsigned __int64(*p);
}

string_type* CoreTypes::Box(string_type* p)
{
	if (p == 0) return 0;
	return new string_type(*p);
}

altova::DateTime* CoreTypes::Box(altova::DateTime* p)
{
	if (p == 0) return 0;
	return new altova::DateTime(*p);
}

altova::Duration* CoreTypes::Box(altova::Duration* p)
{
	if (p == 0) return 0;
	return new altova::Duration(*p);
}

double* CoreTypes::Box(double* p)
{
	if (p == 0) return 0;
	return new double(*p);
}

int CoreTypes::Unbox(int* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

bool CoreTypes::Unbox(bool* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

unsigned CoreTypes::Unbox(unsigned* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

__int64 CoreTypes::Unbox(__int64* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

unsigned __int64 CoreTypes::Unbox(unsigned __int64* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

string_type CoreTypes::Unbox(string_type* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

altova::DateTime CoreTypes::Unbox(altova::DateTime* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

altova::Duration CoreTypes::Unbox(altova::Duration* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

double CoreTypes::Unbox(double* v)
{
	if (v == 0)
		throw altova::Error(_T("Trying to read NULL value."));
	return *v;
}

}



namespace altova {



////////////////////////////////////////////////////////////////////////
//
//  CSchemaType
//
////////////////////////////////////////////////////////////////////////
CSchemaType::CSchemaType() 
: m_bIsEmpty( true ) 
, m_bIsNull( false )
{
	Empty();
};


bool CSchemaType::Parse( const TCHAR* szValue )
{
	Empty();
	return !( m_bIsEmpty = ( szValue[ 0 ] == 0 ) );
}


CSchemaType& CSchemaType::Assign( const CSchemaType& rOther )
{
	Empty();
	m_bIsEmpty = rOther.m_bIsEmpty;
	m_bIsNull = rOther.m_bIsNull;
	return *this;
}





const TCHAR*	CSchemaType::SchemaType2String(ETypes eType)
{
	switch( eType )
	{
	case k_bool:			return _T("boolean");
	case k_byte:			return _T("byte");
	case k_unsigned_byte:	return _T("unsigned byte");
	case k_short:			return _T("short");
	case k_unsigned_short:	return _T("unsigned short");
	case k_int:				return _T("int");
	case k_unsigned_int:	return _T("unsigned int");
	case k_long:			return _T("long");
	case k_unsigned_long:	return _T("unsigned long");
	case k_float:			return _T("float");
	case k_double:			return _T("double");
	case k_decimal:			return _T("decimal");
	// calendar types
	case k_Duration:		return _T("duration");
	case k_Time:			return _T("time");
	case k_Day:				return _T("gDay");
	case k_Month:			return _T("gMonth");
	case k_MonthDay:		return _T("gMonthDay");
	case k_Year:			return _T("gYear");
	case k_YearMonth:		return _T("gYearMonth");
	case k_Date:			return _T("date");
	case k_DateTime:		return _T("datetime");
	// else
	case k_String:			return _T("string");
	case k_Base64Binary:	return _T("base64binary");
	case k_HexBinary:		return _T("hexbinary");
	}
	return _T("invalid");
}

tstring CSchemaType::normalize(CSchemaType::EWhitespaceFacet wf, const TCHAR* sz)
{
	if (wf == CSchemaType::WHITESPACE_PRESERVE)
		return sz;
		
	
	tstring str = sz;
	std::replace(str.begin(), str.end(), _T('\n'), _T(' '));
	std::replace(str.begin(), str.end(), _T('\r'), _T(' '));
	std::replace(str.begin(), str.end(), _T('\t'), _T(' '));
	
	
	if (wf == CSchemaType::WHITESPACE_COLLAPSE)
	{

		// trim
		tstring::size_type i = str.find_last_not_of(_T(' '));
		if (i != tstring::npos)
		{
			str.erase(i + 1);
			i = str.find_first_not_of(' ');
			if(i != tstring::npos) str.erase(0, i);
		}
		else 
			str.erase(str.begin(), str.end());
		
		// collapse
		for (i = 1; i<str.size();)
		{
			if (str[i] == _T(' ') && str[i-1] == _T(' '))
				str.erase(i, 1);
			else
				i++;
		}
	
	}

	return str;
}



////////////////////////////////////////////////////////////////////////
//
//  Operators
//
////////////////////////////////////////////////////////////////////////


// equality / not-equal
bool CSchemaType::CompareEqual(const CSchemaType& rObj1, const CSchemaType& rObj2 )
{
	if( rObj1.IsEmpty() != rObj2.IsEmpty() )
		return false;

	const CSchemaType* pObj1 = &rObj1;
	const CSchemaType* pObj2 = &rObj2;
	
	// try strings first; if at least one of them is string compare them as strings
	const CSchemaString* pStr1 = dynamic_cast<const CSchemaString*>(pObj1);
	const CSchemaString* pStr2 = dynamic_cast<const CSchemaString*>(pObj2);
	if (pStr1 || pStr2)
		return ((tstring) rObj1 == (tstring) rObj2);

	// check numeric types
	try
	{
		const CSchemaTypeNumber* pNum1 = dynamic_cast<const CSchemaTypeNumber*>(pObj1);
		const CSchemaTypeNumber* pNum2 = dynamic_cast<const CSchemaTypeNumber*>(pObj2);
		if( pNum1 &&  pNum2 && 
			pNum1->NumericType() != CSchemaType::k_unknown  &&
			pNum2->NumericType() != CSchemaType::k_unknown )
		{	// both derived from CSchemaTypeNumber
			CSchemaType::ETypes eType1 = pNum1->NumericType();
			CSchemaType::ETypes eType2 = pNum2->NumericType();
			if( eType1 == CSchemaType::k_float  ||  
				eType1 == CSchemaType::k_double  ||  
				eType1 == CSchemaType::k_decimal ||
				eType2 == CSchemaType::k_float  ||  
				eType2 == CSchemaType::k_double  ||  
				eType2 == CSchemaType::k_decimal )
				return pNum1->ToDouble() == pNum2->ToDouble();
			if( pNum1->NumericType() == CSchemaType::k_unsigned_long  ||
				pNum2->NumericType() == CSchemaType::k_unsigned_long )
				return (unsigned __int64)pNum1->ToInt64() == (unsigned __int64)pNum2->ToInt64();
			return pNum1->ToInt64() == pNum2->ToInt64();
		}
	}
	catch(std::exception) {}

	// check calendar-types
	try
	{
		const CSchemaTypeCalendar* pCal1 = dynamic_cast<const CSchemaTypeCalendar*>(pObj1);
		const CSchemaTypeCalendar* pCal2 = dynamic_cast<const CSchemaTypeCalendar*>(pObj2);
		if( pCal1  &&  pCal2  &&
			pCal1->CalendarType() != CSchemaType::k_unknown  &&
			pCal2->CalendarType() != CSchemaType::k_unknown  )
		{	// both derived from CSchemaCalendar
			switch( pCal1->CalendarType() )
			{
			case CSchemaType::k_Duration:
				{
					CSchemaDuration dur1( rObj1 );
					CSchemaDuration dur2( rObj2 );
					return dur1.GetValue().ApproximatedNormalizedSeconds() == dur2.GetValue().ApproximatedNormalizedSeconds();
				}
			case CSchemaType::k_Date:
				{
					CSchemaDate t1( rObj1 );
					CSchemaDate t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone() )
						return t1.GetValue().ApproximatedNormalizedDays() == t2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Time:
				{
					CSchemaTime t1( rObj1 );
					CSchemaTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().NormalizedSeconds() == t2.GetValue().NormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_DateTime:
				{
					CSchemaDateTime t1( rObj1 );
					CSchemaDateTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().ApproximatedNormalizedSeconds() == t2.GetValue().ApproximatedNormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_Year:
				{
					CSchemaYear year1( rObj1 );
					CSchemaYear year2( rObj2 );
					if( year1.GetValue().HasTimezone() == year2.GetValue().HasTimezone() )
						return year1.GetValue().nYear == year2.GetValue().nYear;
					else
						return false;
				}
			case CSchemaType::k_YearMonth:
				{
					CSchemaYearMonth ym1( rObj1 );
					CSchemaYearMonth ym2( rObj2 );
					if( ym1.GetValue().HasTimezone() == ym2.GetValue().HasTimezone() )
						return ym1.GetValue().NormalizedMonths() == ym2.GetValue().NormalizedMonths();
					else
						return false;

				}
			case CSchemaType::k_Month:
				{
					CSchemaMonth mon1( rObj1 );
					CSchemaMonth mon2( rObj2 );
					if( mon1.GetValue().HasTimezone() == mon2.GetValue().HasTimezone() )
						return mon1.GetValue().nMonth == mon2.GetValue().nMonth;
					else
						return false;
				}
			case CSchemaType::k_MonthDay:
				{
					CSchemaMonthDay md1( rObj1 );
					CSchemaMonthDay md2( rObj2 );
					if( md1.GetValue().HasTimezone() == md2.GetValue().HasTimezone() )
						return md1.GetValue().ApproximatedNormalizedDays() == md2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Day:
				{
					CSchemaDay day1( rObj1 );
					CSchemaDay day2( rObj2 );
					if( day1.GetValue().HasTimezone() == day2.GetValue().HasTimezone() )
						return day1.GetValue().nDay == day2.GetValue().nDay;
					else
						return false;
				}
			}

		}
	}
	catch(std::exception) {}

	// check binary-types
	try
	{
		const CSchemaBinaryBase* pBin1 = dynamic_cast<const CSchemaBinaryBase*>(pObj1);
		const CSchemaBinaryBase* pBin2 = dynamic_cast<const CSchemaBinaryBase*>(pObj2);
		if( pBin1  &&  pBin2 )
		{	// binary types
			if( pBin1->m_nSize == pBin2->m_nSize )
				return memcmp(pBin1->m_pData, pBin2->m_pData, pBin1->m_nSize ) == 0;
			return false;
		}
	}
	catch(std::exception) {}

	return (tstring)rObj1 == (tstring)rObj2;
}


// less
bool CSchemaType::CompareLess(const CSchemaType& rObj1, const CSchemaType& rObj2 )
{
	if( rObj1.IsEmpty() && rObj2.IsEmpty() )
		return false;
	if( rObj1.IsEmpty() )
		return true;
	if( rObj2.IsEmpty() )
		return false;

	const CSchemaType* pObj1 = &rObj1;
	const CSchemaType* pObj2 = &rObj2;
	
	// try strings first; if at least one of them is string compare them as strings
	const CSchemaString* pStr1 = dynamic_cast<const CSchemaString*>(pObj1);
	const CSchemaString* pStr2 = dynamic_cast<const CSchemaString*>(pObj2);
	if (pStr1 || pStr2)
		return ((tstring) rObj1 < (tstring) rObj2);

	// check numeric types
	try
	{
		const CSchemaTypeNumber* pNum1 = dynamic_cast<const CSchemaTypeNumber*>(pObj1);
		const CSchemaTypeNumber* pNum2 = dynamic_cast<const CSchemaTypeNumber*>(pObj2);
		if( pNum1 &&  pNum2 && 
			pNum1->NumericType() != CSchemaType::k_unknown  &&
			pNum2->NumericType() != CSchemaType::k_unknown )
		{	// both derived from CSchemaTypeNumber
			CSchemaType::ETypes eType1 = pNum1->NumericType();
			CSchemaType::ETypes eType2 = pNum2->NumericType();
			if( eType1 == CSchemaType::k_float  ||  
				eType1 == CSchemaType::k_double  ||  
				eType1 == CSchemaType::k_decimal ||
				eType2 == CSchemaType::k_float  ||  
				eType2 == CSchemaType::k_double  ||  
				eType2 == CSchemaType::k_decimal )
				return pNum1->ToDouble() < pNum2->ToDouble();
			if( pNum1->NumericType() == CSchemaType::k_unsigned_long  ||
				pNum2->NumericType() == CSchemaType::k_unsigned_long )
				return (unsigned __int64)pNum1->ToInt64() < (unsigned __int64)pNum2->ToInt64();
			return pNum1->ToInt64() < pNum2->ToInt64();
		}
	}
	catch(std::exception) {}

	// check calendar-types
	try
	{
		const CSchemaTypeCalendar* pCal1 = dynamic_cast<const CSchemaTypeCalendar*>(pObj1);
		const CSchemaTypeCalendar* pCal2 = dynamic_cast<const CSchemaTypeCalendar*>(pObj2);
		if( pCal1  &&  pCal2  &&
			pCal1->CalendarType() != CSchemaType::k_unknown  &&
			pCal2->CalendarType() != CSchemaType::k_unknown  )
		{	// both derived from CSchemaCalendar
			switch( pCal1->CalendarType() )
			{
			case CSchemaType::k_Duration:
				{
					CSchemaDuration dur1( rObj1 );
					CSchemaDuration dur2( rObj2 );
					return dur1.GetValue().ApproximatedNormalizedSeconds() < dur2.GetValue().ApproximatedNormalizedSeconds();
				}
			case CSchemaType::k_Date:
				{
					CSchemaDate t1( rObj1 );
					CSchemaDate t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone() )
						return t1.GetValue().ApproximatedNormalizedDays() < t2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Time:
				{
					CSchemaTime t1( rObj1 );
					CSchemaTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().NormalizedSeconds() < t2.GetValue().NormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_DateTime:
				{
					CSchemaDateTime t1( rObj1 );
					CSchemaDateTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().ApproximatedNormalizedSeconds() < t2.GetValue().ApproximatedNormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_Year:
				{
					CSchemaYear year1( rObj1 );
					CSchemaYear year2( rObj2 );
					if( year1.GetValue().HasTimezone() == year2.GetValue().HasTimezone() )
						return year1.GetValue().nYear < year2.GetValue().nYear;
					else
						return false;
				}
			case CSchemaType::k_YearMonth:
				{
					CSchemaYearMonth ym1( rObj1 );
					CSchemaYearMonth ym2( rObj2 );
					if( ym1.GetValue().HasTimezone() == ym2.GetValue().HasTimezone() )
						return ym1.GetValue().NormalizedMonths() < ym2.GetValue().NormalizedMonths();
					else
						return false;

				}
			case CSchemaType::k_Month:
				{
					CSchemaMonth mon1( rObj1 );
					CSchemaMonth mon2( rObj2 );
					if( mon1.GetValue().HasTimezone() == mon2.GetValue().HasTimezone() )
						return mon1.GetValue().nMonth < mon2.GetValue().nMonth;
					else
						return false;
				}
			case CSchemaType::k_MonthDay:
				{
					CSchemaMonthDay md1( rObj1 );
					CSchemaMonthDay md2( rObj2 );
					if( md1.GetValue().HasTimezone() == md2.GetValue().HasTimezone() )
						return md1.GetValue().ApproximatedNormalizedDays() < md2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Day:
				{
					CSchemaDay day1( rObj1 );
					CSchemaDay day2( rObj2 );
					if( day1.GetValue().HasTimezone() == day2.GetValue().HasTimezone() )
						return day1.GetValue().nDay < day2.GetValue().nDay;
					else
						return false;
				}
			}

		}
	}
	catch(std::exception) {}

	// check binary-types
	try
	{
		const CSchemaBinaryBase* pBin1 = dynamic_cast<const CSchemaBinaryBase*>(pObj1);
		const CSchemaBinaryBase* pBin2 = dynamic_cast<const CSchemaBinaryBase*>(pObj2);
		if( pBin1  &&  pBin2 )
		{	// binary types
			if( pBin1->m_nSize == pBin2->m_nSize )
				return memcmp(pBin1->m_pData, pBin2->m_pData, pBin1->m_nSize ) < 0;
			return pBin1->m_nSize < pBin2->m_nSize;
		}
	}
	catch(std::exception) {}

	return (tstring)rObj1 < (tstring)rObj2;
}



 



} // namespace altova
