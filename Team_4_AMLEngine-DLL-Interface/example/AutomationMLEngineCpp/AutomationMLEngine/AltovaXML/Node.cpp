////////////////////////////////////////////////////////////////////////
//
// Node.cpp
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "../Altova/Altova.h"
#include "../Altova/AltovaException.h"
#include "../Altova/SchemaTypes.h"
#include "../Altova/SchemaTypeString.h"
#include "XmlException.h"
#include "Node.h"
#include "Doc.h"
#include "XercesString.h"
#include <stdio.h>
#include <string.h>

#ifdef _WIN32
#include <tchar.h>
#endif // _WIN32

#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/framework/MemBufInputSource.hpp>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xercesc/framework/MemBufFormatTarget.hpp>
#include <xercesc/sax2/DefaultHandler.hpp>
#include <xercesc/util/XMLString.hpp>

#define X(str) XStr(str).unicodeForm()

#if defined(UNICODE) || defined(_UNICODE)

bool XercesTreeOperations::IsEqualString(const XMLCh* a, const char_type* b)
{
	if (a == b) return true;
	if (a == 0) a = L"";
	if (b == 0) b = L"";
	return _tcscmp(a, b) == 0;
}

#else

bool XercesTreeOperations::IsEqualString(const XMLCh* a, const char_type* b)
{
	if (a == 0) a = (XMLCh*)L"";
	if (b == 0) b = _T("");
	while (*a && *b)
	{
		if (*a != *b)
			return false;
		++a, ++b;
	}
	return (*a == *b);	// terminator
}

#endif


static string_type GetTextContent(const xercesc::DOMNode* pNode)
{
	short nodeType = pNode->getNodeType();
	switch (nodeType)
	{
	case xercesc::DOMNode::ATTRIBUTE_NODE:
	case xercesc::DOMNode::PROCESSING_INSTRUCTION_NODE:
	case xercesc::DOMNode::COMMENT_NODE:
	case xercesc::DOMNode::TEXT_NODE:
	case xercesc::DOMNode::CDATA_SECTION_NODE:
		return string_type(XercesUnstringTemp(pNode->getNodeValue()));

	case xercesc::DOMNode::DOCUMENT_NODE:
	case xercesc::DOMNode::DOCUMENT_FRAGMENT_NODE:
	case xercesc::DOMNode::ELEMENT_NODE:
	case xercesc::DOMNode::ENTITY_REFERENCE_NODE:
		{
			string_type result;
			for (xercesc::DOMNode* pChild = pNode->getFirstChild(); pChild != 0; pChild = pChild->getNextSibling())
			{
				short childNodeType = pChild->getNodeType();
				switch (childNodeType)
				{
				case xercesc::DOMNode::TEXT_NODE:
				case xercesc::DOMNode::CDATA_SECTION_NODE:
				case xercesc::DOMNode::ELEMENT_NODE:
				case xercesc::DOMNode::ENTITY_REFERENCE_NODE:
					result += GetTextContent(pChild);
					break;
				}
			}
			return result;
		}
	}
	return string_type();
}

static void FindDeclarationsForNamespace(xercesc::DOMNode* pNode, const string_type& uri, std::vector<xercesc::DOMNode*>& declarations)
{
	if (pNode->getParentNode() != 0)
		FindDeclarationsForNamespace(pNode->getParentNode(), uri, declarations);

	xercesc::DOMNamedNodeMap* attrs = pNode->getAttributes();
	if (attrs == 0)
		return;

	XMLSize_t length = attrs->getLength();
	for (XMLSize_t index = 0; index != length; ++index)
	{
		xercesc::DOMNode* att = attrs->item(index);
		if (string_type(XercesUnstringTemp(att->getPrefix())) == string_type(_T("xmlns")))
		{
			if (string_type(XercesUnstringTemp(att->getNodeValue())) == uri)
			{
				declarations.push_back(att);
			}
			else
			{
				for (std::vector<xercesc::DOMNode*>::iterator it = declarations.begin(); it != declarations.end(); )
				{
					xercesc::DOMNode* cur = *it;

					if (xercesc::XMLString::compareString(cur->getLocalName(), att->getLocalName()) == 0)
						declarations.erase(it);
					else
						++it;
				}
			}
		}
	}
}

static string_type FindPrefixForNamespace(xercesc::DOMNode* node, const string_type& uri)
{
	if (uri == string_type(_T("http://www.w3.org/XML/1998/namespace")))
		return string_type(_T("xml"));

	string_type prefix;

	std::vector<xercesc::DOMNode*> declarations;
	FindDeclarationsForNamespace(node, uri, declarations);
	if (!declarations.empty())
		prefix = string_type(XercesUnstringTemp(declarations.front()->getLocalName()));
	else
		prefix = string_type(_T(""));
	return prefix;
}

static string_type FindUnusedPrefix(xercesc::DOMNode* node)
{
	int n = 0;
	while (true)
	{
		char_type buf[30];
		_stprintf(buf, _T("n%u"), n);
		if (node->getAttributes()->getNamedItemNS(XercesStringTemp(_T("http://www.w3.org/2000/xmlns/")), XercesStringTemp(buf)) == 0)
			return buf;
	}
}

void XercesTreeOperations::CopyAll(const xercesc::DOMNode* src, xercesc::DOMNode* tgt)
{
	// nodes
	for(xercesc::DOMNode* node = src->getFirstChild(); node != 0; node = node->getNextSibling())
		tgt->appendChild(tgt->getOwnerDocument()->importNode(node, true));
	// attributes
	xercesc::DOMNamedNodeMap* attrz = src->getAttributes();
	for (size_t i=0; i< attrz->getLength(); i++)
		((xercesc::DOMElement*)tgt)->setAttributeNode((xercesc::DOMAttr*)tgt->getOwnerDocument()->importNode(attrz->item(i), true));
}

bool XercesTreeOperations::IsMember( xercesc::DOMNode* pNode, const altova::MemberInfo* pMember )
{
	if (*pMember->LocalName == 0)
		return pNode->getNodeType() == xercesc::DOMNode::TEXT_NODE ||
		pNode->getNodeType() == xercesc::DOMNode::CDATA_SECTION_NODE;

	if (pNode->getNodeType() != xercesc::DOMNode::ELEMENT_NODE)
		return false;

	const XMLCh* pName = pNode->getLocalName();
	if (pName == 0)
		pName = pNode->getNodeName();

	return IsEqualString(pName, pMember->LocalName) &&
		IsEqualString(pNode->getNamespaceURI(), pMember->NamespaceURI);
}


bool XercesTreeOperations::IsValid(xercesc::DOMNode* pNode)
{
	return pNode != 0;
}

XercesTreeOperations::AllIterator XercesTreeOperations::GetElements(xercesc::DOMNode* pNode)
{
	return AllIterator(pNode->getFirstChild());
}

XercesTreeOperations::MemberIterator XercesTreeOperations::GetElements(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return MemberIterator(pNode->getFirstChild(), pMemberInfo);
}

void XercesTreeOperations::SetTextValue(xercesc::DOMNode* pNode, const string_type& sText)
{
	while (pNode->getFirstChild())
	{
		delete pNode->removeChild(pNode->getFirstChild());
	}

	pNode->appendChild(pNode->getOwnerDocument()->createTextNode(XercesStringTemp(sText)));
//	pNode->setNodeValue(XercesStringTemp(sText));
}

string_type XercesTreeOperations::GetTextValue(xercesc::DOMNode* pNode)
{
	return string_type(GetTextContent(pNode));
}


void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const XMLCh* bValue)
{
	if (*pMemberInfo->LocalName != 0)
	{
		string_type prefix;
		if (*pMemberInfo->NamespaceURI)
		{
			prefix = FindPrefixForNamespace(pNode, pMemberInfo->NamespaceURI);
			if (prefix.empty())
				prefix = FindUnusedPrefix(pNode) + _T(":");
			else
				prefix += _T(":");
		}

		xercesc::DOMNode* pAttr = pNode->getOwnerDocument()->createAttributeNS(
			XercesStringTemp(pMemberInfo->NamespaceURI),
			XercesStringTemp(prefix + pMemberInfo->LocalName));
		pAttr->setNodeValue(bValue);
		pNode->getAttributes()->setNamedItemNS(pAttr);
	}
	else
	{
		while (pNode->hasChildNodes())
		{
			delete pNode->removeChild(pNode->getFirstChild());
		}

		pNode->appendChild(pNode->getOwnerDocument()->createTextNode(bValue));
	}
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const string_type& sValue)
{
	SetValue(pNode, pMemberInfo, XercesStringTemp(sValue));
}

inline altova::XmlFormatter* GetFormatter(const altova::MemberInfo* pMember)
{
	if (((pMember->Binder->Types + pMember->DataType)->Formatter))
		return static_cast<altova::XmlFormatter*>(*((pMember->Binder->Types + pMember->DataType)->Formatter));
	else
		return static_cast<altova::XmlFormatter*>(altova::AnySimpleTypeFormatter);
}


void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, bool b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, int b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format((__int64)b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, unsigned b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format((unsigned __int64)b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, __int64 b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, unsigned __int64 b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, double b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, altova::DateTime b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, altova::Duration b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const std::vector<unsigned char>& b)
{
	SetValue(pNode, pMemberInfo, GetFormatter(pMemberInfo)->Format(b));
}


void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const xercesc::DOMNode* b)
{
	SetValue(pNode, pMemberInfo, GetTextContent(b));
}



xercesc::DOMNode* XercesTreeOperations::AddElement(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
    xercesc::DOMNode* pNewNode = CreateElement(pNode,pMemberInfo);
    pNode->appendChild(pNewNode);
    return pNewNode;
}

xercesc::DOMNode* XercesTreeOperations::CreateElement(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	string_type prefix;
	if (*pMemberInfo->NamespaceURI)
	{
		prefix = FindPrefixForNamespace(pNode, pMemberInfo->NamespaceURI);
		if (!prefix.empty())
			prefix += _T(":");
	}

	xercesc::DOMDocument* pDoc = pNode->getOwnerDocument();
	if ( pDoc == 0 )
		pDoc = ( xercesc::DOMDocument* )pNode;
	xercesc::DOMNode* pNewNode = pDoc->createElementNS(
		XercesStringTemp(pMemberInfo->NamespaceURI),
		XercesStringTemp(prefix + pMemberInfo->LocalName));
	return pNewNode;
}

double XercesTreeOperations::CastToDouble(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToDouble(GetTextContent(pNode));
}


string_type XercesTreeOperations::CastToString(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToString(GetTextContent(pNode));
}


__int64 XercesTreeOperations::CastToInt64(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToInt64(GetTextContent(pNode));
}

unsigned __int64 XercesTreeOperations::CastToUInt64(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToUInt64(GetTextContent(pNode));
}

unsigned XercesTreeOperations::CastToUInt(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToUInt(GetTextContent(pNode));
}

int XercesTreeOperations::CastToInt(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToInt(GetTextContent(pNode));
}


bool XercesTreeOperations::CastToBool(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToBool(GetTextContent(pNode));
}

altova::DateTime XercesTreeOperations::CastToDateTime(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToDateTime(GetTextContent(pNode));
}

altova::Duration XercesTreeOperations::CastToDuration(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return altova::CoreTypes::CastToDuration(GetTextContent(pNode));
}

std::vector<unsigned char> XercesTreeOperations::CastToBinary(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
{
	return GetFormatter(pMemberInfo)->ParseBinary(GetTextContent(pNode));
}


xercesc::DOMNode* XercesTreeOperations::FindAttribute(
	xercesc::DOMNode* pNode, const altova::MemberInfo* member)
{
	return pNode->getAttributes()->getNamedItemNS(XercesStringTemp(member->NamespaceURI), XercesStringTemp(member->LocalName));
}


xercesc::DOMNode* XercesTreeOperations::GetParent(xercesc::DOMNode* pNode)
{
	return pNode->getParentNode();
}

void XercesTreeOperations::SetValue(xercesc::DOMNode* pNode, const string_type& sValue)
{
	pNode->setNodeValue(XercesStringTemp(sValue.c_str()));
}

void XercesTreeOperations::RemoveAttribute(xercesc::DOMNode* pNode, const altova::MemberInfo* member)
{
	if (*member->LocalName)
	{
		if (pNode->hasAttributes())
			pNode->getAttributes()->removeNamedItemNS(XercesStringTemp(member->NamespaceURI), XercesStringTemp(member->LocalName));
	}
	else
	{
		for (xercesc::DOMNode* pChild = pNode->getFirstChild(); pChild; )
		{
			xercesc::DOMNode* cur = pChild;
			pChild = pChild->getNextSibling();
			if (cur->getNodeType() == xercesc::DOMNode::TEXT_NODE ||
				cur->getNodeType() == xercesc::DOMNode::CDATA_SECTION_NODE)
			{
				pNode->removeChild(cur);
			}
		}
	}
}

void XercesTreeOperations::RemoveElements(xercesc::DOMNode* pNode, const altova::MemberInfo* member)
{
	for (xercesc::DOMNode* pChild = pNode->getFirstChild(); pChild; )
	{
		xercesc::DOMNode* cur = pChild;
		pChild = pChild->getNextSibling();
		if (IsMember(cur, member))
			pNode->removeChild(cur);
	}
}

void XercesTreeOperations::RemoveElement(xercesc::DOMNode* pNode, const altova::MemberInfo* member, unsigned index)
{
	for (xercesc::DOMNode* pChild = pNode->getFirstChild(); pChild; )
	{
		xercesc::DOMNode* cur = pChild;
		pChild = pChild->getNextSibling();
		if (IsMember(cur, member) && index-- == 0)
		{
			pNode->removeChild(cur);
			break;
		}
	}
}


XercesTreeOperations::DocumentType XercesTreeOperations::LoadDocument(
	const string_type& filename)
{
	try
	{
		xercesc::XercesDOMParser parser;
		xercesc::DefaultHandler defaultHandler;
		parser.setErrorHandler(&defaultHandler);
		parser.setDoNamespaces(true);
		parser.parse(XercesStringTemp(filename));
		DocumentType doc = parser.adoptDocument();
		return doc;
	}
	catch (xercesc::XMLException& error)
	{
		throw altova::DataSourceUnavailableException(filename + _T(": Xerces XML error while loading: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::SAXException& error)
	{
		throw altova::DataSourceUnavailableException(filename + _T(": Xerces SAX error while loading: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::DOMException&)
	{
		throw altova::DataSourceUnavailableException(filename + _T(": Xerces DOM error while loading"));
	}
}

void XercesTreeOperations::FreeDocument(DocumentType& document)
{
	document->release();
	document = 0;
}

void XercesTreeOperations::SaveDocument( const DocumentType& document, const string_type& filename, bool prettyPrint )
{
	SaveDocument( document, filename, prettyPrint, _T("UTF-8"), false, false );
}

void XercesTreeOperations::SaveDocument( const DocumentType& document, const string_type& filename, bool prettyPrint, const string_type& encoding, bool bBigEndian, bool bBOM )
{
	std::vector<unsigned char> bytes;
	SaveToBinary( bytes, document, prettyPrint, encoding, bBigEndian, bBOM );

	FILE *f = _tfopen( filename.c_str(), _T("wb") );
	if( !f )
		throw altova::DataTargetUnavailableException( _T("Could not open file ") + filename + _T(" for writing.") );

	fwrite( &bytes[0], bytes.size(), 1, f );
	fclose( f );
}

XercesTreeOperations::DocumentType XercesTreeOperations::LoadXml(const string_type& xml)
{
	try
	{
		xercesc::XercesDOMParser parser;
		xercesc::DefaultHandler defaultHandler;
		parser.setErrorHandler(&defaultHandler);
		parser.setDoNamespaces(true);

		xercesc::MemBufInputSource source(
			( XMLByte* ) xml.data(),
			xml.size() * sizeof( char_type ),
			"String");

		parser.parse(source);
		DocumentType doc = parser.adoptDocument();
		return doc;
	}
	catch (xercesc::XMLException& error)
	{
		throw altova::DataSourceUnavailableException(_T("Xerces XML error while loading: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::SAXException& error)
	{
		throw altova::DataSourceUnavailableException(_T("Xerces SAX error while loading: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::DOMException&)
	{
		throw altova::DataSourceUnavailableException(_T("Xerces DOM error while loading"));
	}
}

XercesTreeOperations::DocumentType XercesTreeOperations::LoadFromBinary(const std::vector<unsigned char>& binary)
{
	try
	{
		xercesc::XercesDOMParser parser;
		xercesc::DefaultHandler defaultHandler;
		parser.setErrorHandler(&defaultHandler);
		parser.setDoNamespaces(true);

		xercesc::MemBufInputSource source(
			( XMLByte* ) &*binary.begin(),
			binary.size(),
			"String");

		parser.parse(source);
		DocumentType doc = parser.adoptDocument();
		return doc;
	}
	catch (xercesc::XMLException& error)
	{
		throw altova::DataSourceUnavailableException(_T("Xerces XML error while loading: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::SAXException& error)
	{
		throw altova::DataSourceUnavailableException(_T("Xerces SAX error while loading: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::DOMException&)
	{
		throw altova::DataSourceUnavailableException(_T("Xerces DOM error while loading"));
	}
}


namespace
{
	class HoldXMLString
	{
		XMLCh* data;
	public:
		HoldXMLString(XMLCh* str) : data(str) {}
		~HoldXMLString() { xercesc::XMLString::release(&data); }
		operator const XMLCh*() const { return data; }
	};

	class HoldDOMWriter
	{
		xercesc::DOMWriter* data;
	public:
		HoldDOMWriter(xercesc::DOMWriter* writer) : data(writer) {}
		~HoldDOMWriter() { data->release(); }
		xercesc::DOMWriter* operator->() { return data; }
	};
}


string_type XercesTreeOperations::SaveXml(const DocumentType& document, bool prettyPrint)
{
	try
	{
		HoldDOMWriter pWriter(xercesc::DOMImplementation::getImplementation()->createDOMWriter());
		if (prettyPrint && pWriter->canSetFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true))
		{
			pWriter->setFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true);
		}
		HoldXMLString resultXML(pWriter->writeToString(*document));
		string_type result = (string_type)XercesUnstringTemp(resultXML);
		return result;
	}
	catch (xercesc::XMLException& error)
	{
		throw altova::DataTargetUnavailableException(_T("Xerces XML error while saving: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::SAXException& error)
	{
		throw altova::DataTargetUnavailableException(_T("Xerces SAX error while saving: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::DOMException&)
	{
		throw altova::DataTargetUnavailableException(_T("Xerces DOM error while saving"));
	}
}

XercesTreeOperations::DocumentType XercesTreeOperations::CreateDocument()
{
	xercesc::DOMDocument* doc = xercesc::DOMImplementation::getImplementation()->createDocument();
	return doc;
}

void XercesTreeOperations::AddProcessingInstruction(xercesc::DOMNode* node, const string_type& target, const string_type& value)
{
	xercesc::DOMDocument* doc = node->getOwnerDocument();
	if (doc == 0)
		doc = (xercesc::DOMDocument*)node;

	node->appendChild(doc->createProcessingInstruction(XercesStringTemp(target), XercesStringTemp(value)));
}

std::vector<unsigned char> XercesTreeOperations::SaveToBinary(const DocumentType& document, bool prettyPrint)
{
	std::vector<unsigned char> result;
	SaveToBinary( result, document, prettyPrint, _T(""), false, false, false );
	return result;
}

void XercesTreeOperations::SaveToBinary( std::vector<unsigned char>& result, const DocumentType& document, bool prettyPrint, const string_type& encoding, bool bBigEndian, bool bBOM, bool bIncludeEncoding )
{
	try
	{
		// this is going to leak on exception:
		HoldDOMWriter pWriter( xercesc::DOMImplementation::getImplementation()->createDOMWriter() );

		if (prettyPrint && pWriter->canSetFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true))
		{
			pWriter->setFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true);
		}

		xercesc::MemBufFormatTarget target;
		if( bIncludeEncoding )
			pWriter->setEncoding(XercesStringTemp(encoding));
		bool bRet = pWriter->writeNode(&target, *document);
		result.clear();
		result.insert(result.end(), target.getRawBuffer(), target.getRawBuffer() + target.getLen());

		if( bIncludeEncoding )
			CorrectByteOrderAndBOM( result, encoding, bBigEndian, bBOM );

		if( !bRet )
			throw altova::DataTargetUnavailableException( _T("Xerces XML error while saving.") );
	}
	catch (xercesc::XMLException& error)
	{
		throw altova::DataTargetUnavailableException(_T("Xerces XML error while saving: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::SAXException& error)
	{
		throw altova::DataTargetUnavailableException(_T("Xerces SAX error while saving: ") + string_type(XercesUnstringTemp(error.getMessage())));
	}
	catch (xercesc::DOMException&)
	{
		throw altova::DataTargetUnavailableException(_T("Xerces DOM error while saving"));
	}
}

void XercesTreeOperations::CorrectByteOrderAndBOM( std::vector<unsigned char>& bytes, const string_type& encoding, bool bBigEndian, bool bBOM )
{
	if( bytes.size() == 0 || encoding.empty() )
		return;

	int unisize = GetUnicodeSizeFromEncodingName( encoding );
	if( unisize == 0 )
		return;

	if( unisize < 2 )
		bBigEndian = false;

	int encbo = GetEncodingAndByteOrderFromXml( bytes );

	bool bHasBOM = (encbo & 0x10) != 0;
	bool bIsBigEndian = (encbo & 0x20) != 0;

	if( bBOM == bHasBOM && bBigEndian == bIsBigEndian )
		return;

	int off = 0;
	int len = (int) bytes.size();

	if( unisize > 0 && bBOM && !bHasBOM )
	{
		if( unisize == 1 )
		{
			bytes.insert( bytes.begin(), 3, 0 );
			bytes[0] = 0xef;
			bytes[1] = 0xbb;
			bytes[2] = 0xbf;
			off = 3;
		}
		else
		if( unisize == 2 )
		{
			if( bBigEndian ) {
				bytes.insert( bytes.begin(), 2, 0 );
				bytes[0] = 0xfe;
				bytes[1] = 0xff;
				off = 2;
			} else {
				bytes.insert( bytes.begin(), 2, 0 );
				bytes[0] = 0xff;
				bytes[1] = 0xfe;
				off = 2;
			}
		}
	}

	if( !bBOM && bHasBOM )
	{
		int bomsize = (encbo & 0xf00) >> 8;
		off += bomsize;
		len -= bomsize;
	}

	if( bBigEndian != bIsBigEndian && unisize >= 2 )
	{
		unsigned char* ptr = &bytes[0];
		ptr += off;
		int count = (len / unisize) * unisize;
		for( int i = 0 ; i < count ; i += unisize, ptr += unisize )
		{
			unsigned char h = ptr[1];
			ptr[1] = ptr[0];
			ptr[0] = h;
		}
	}
	else if( off > 0 )
		bytes.erase( bytes.begin(), bytes.begin() + off );
}

// Returns
//	bits 0-3:		encoding char size in bytes (1 = UTF-8, 2 = UTF-16 or UCS-2)
//	bit  4:			if BOM is included
//	bit  5:			if BigEndian (set) or LittleEndian (cleared)
//  bits 8-11:		BOM size in bytes
int XercesTreeOperations::GetEncodingAndByteOrderFromXml( std::vector<unsigned char>& sourceBytes )
{
	return sourceBytes.size() > 0 ?
		GetEncodingAndByteOrderFromXml( &sourceBytes[0], (int) sourceBytes.size() ) : 0;
}

// Returns
//	bits 0-3:		encoding char size in bytes (1 = UTF-8, 2 = UTF-16 or UCS-2)
//	bit  4:			if BOM is included
//	bit  5:			if BigEndian (set) or LittleEndian (cleared)
//  bits 8-11:		BOM size in bytes
int XercesTreeOperations::GetEncodingAndByteOrderFromXml( unsigned char* sourceBytes, int sourceLength )
{
	if( sourceBytes == NULL ) return 0;
	if( sourceLength < 2 ) return 0;

	if( ((sourceBytes[0] & 0xff) == 0xfe) && ((sourceBytes[1] & 0xff) == 0xff) )
		return 0x232;	// UTF-16BE with BOM

	if( ((sourceBytes[0] & 0xff) == 0xff) && ((sourceBytes[1] & 0xff) == 0xfe) )
		return 0x212;	// UTF-16LE with BOM

	if( ((sourceBytes[0] & 0xff) == 0x00) && ((sourceBytes[1] & 0xff) == 0x3c) )	// checks for "<" character
		return 0x022;	// UTF-16BE without BOM

	if( ((sourceBytes[0] & 0xff) == 0x3c) && ((sourceBytes[1] & 0xff) == 0x00) )	// checks for "<" character
		return 0x002;	// UTF-16LE without BOM

	if( sourceLength < 3 ) return 0;

	if( ((sourceBytes[0] & 0xff) == 0xef)
			&& ((sourceBytes[1] & 0xff) == 0xbb) && ((sourceBytes[2] & 0xff) == 0xbf) )
		return 0x311;	// UTF-8 with BOM

	return 0;
}

int XercesTreeOperations::GetUnicodeSizeFromEncodingName( const string_type& encodingIn )
{
	string_type encoding = Uppercase( encodingIn );

	if( encoding.find(_T("UTF-8")) != string_type::npos )
		return 1;

	if( encoding.find(_T("UTF-16")) != string_type::npos || encoding.find(_T("UCS-2")) != string_type::npos )
		return 2;

	return 0;
}

string_type XercesTreeOperations::Uppercase( const string_type& str )
{
	string_type result;
	result.reserve( str.length() );
	for (string_type::const_iterator it = str.begin(); it != str.end(); ++it)
		result.append( 1, _totupper(*it) );
	return result;
}

void XercesTreeOperations::SetAttribute(xercesc::DOMNode* node, const string_type& localName, const string_type& namespaceURI, const string_type& value)
{
	string_type prefix;
	if (!namespaceURI.empty())
	{
		prefix = FindPrefixForNamespace(node, namespaceURI);
		if (prefix.empty())
			prefix = FindUnusedPrefix(node) + _T(":");
		else
			prefix += _T(":");
	}

	xercesc::DOMNode* pAttr = node->getOwnerDocument()->createAttributeNS(
		XercesStringTemp(namespaceURI),
		XercesStringTemp(prefix + localName));
	pAttr->setNodeValue(XercesStringTemp(value));
	node->getAttributes()->setNamedItemNS(pAttr);
}



namespace altova {


//#define ADJUST_LOCAL_NAMES


#ifdef ADJUST_LOCAL_NAMES

#define Q2L(x) Q2LHelper(x).GetData()

class Q2LHelper
{
public:
	Q2LHelper(const XMLCh* szQName)
	{
		int nPos = xercesc::XMLString::indexOf(szQName, L':');
		if (nPos != -1)
			m_szLocalName = xercesc::XMLString::replicate(szQName + nPos + 1);
		else
			m_szLocalName = xercesc::XMLString::replicate(szQName);
	}

	~Q2LHelper()
	{
		xercesc::XMLString::release(&m_szLocalName);
	}

	const XMLCh* GetData() const
	{
		return m_szLocalName;
	}

protected:
	XMLCh* m_szLocalName;
};

#else

#define Q2L(x) x

#endif


CNode::CNode()
{
	m_pDOMNode = CDoc::CreateFragment();
}


CNode::CNode(xercesc::DOMNode* pThisNode)
{
	m_pDOMNode = pThisNode;
}


CNode::CNode(xercesc::DOMDocument* pDOMDocument)
{
	m_pDOMNode = pDOMDocument->getDocumentElement();
}


CNode::~CNode()
{
	CDoc::ReleaseFragment(m_pDOMNode);
}


CNode&	CNode::Assign(const CNode& rOther)
{
	tstring innerText = ((CNode&)rOther).InternalGetElementValue();
	InternalSetElementValue( innerText );
	return *this;
}

CNode&  CNode::CopyOf(const CNode& other)
{
	xercesc::DOMNode* newMe = m_pDOMNode->getOwnerDocument()->importNode(other.m_pDOMNode, true);
	if (m_pDOMNode->getParentNode() != 0)
	{
		m_pDOMNode->getParentNode()->replaceChild(newMe, m_pDOMNode);
	}
	CDoc::ReleaseFragment(m_pDOMNode);
	m_pDOMNode = newMe;
	return *this;
}



tstring CNode::GetNodeName()
{
	return XC2TS(m_pDOMNode->getNodeName());
}


tstring CNode::GetNodeValue()
{
	if (m_pDOMNode->getNodeValue())
		return XC2TS(m_pDOMNode->getNodeValue());
	else
		return _T("");
}


xercesc::DOMNode* CNode::GetDOMNode()
{
	return m_pDOMNode;
}


void CNode::MapPrefix(const tstring& sPrefix, const tstring& sURI)
{
	if (sURI.empty())
		return;

	xercesc::DOMElement* pElement = static_cast<xercesc::DOMElement*>(m_pDOMNode);

	InternalDeclareNamespace(pElement, sPrefix, sURI);
}



tstring CNode::GetNodeTextValue(xercesc::DOMNode* pNode)
{
	if (pNode == NULL)
		return _T("");
	if (pNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
//		return XC2TS(pNode->getTextContent());  // this is buggy in Xerces < 2.4 - see http://issues.apache.org/bugzilla/show_bug.cgi?id=24693

		// http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-textContent

		tstring value;
		for (xercesc::DOMNode* pChildNode = pNode->getFirstChild(); pChildNode != NULL; pChildNode = pChildNode->getNextSibling())
		{
			if (pChildNode->getNodeType() != xercesc::DOMNode::COMMENT_NODE &&
				pChildNode->getNodeType() != xercesc::DOMNode::PROCESSING_INSTRUCTION_NODE)
				value += GetNodeTextValue(pChildNode);
		}
		return value;
	}
	else
		return XC2TS(pNode->getNodeValue());
}


tstring CNode::InternalGetElementValue()
{
	return GetNodeTextValue(m_pDOMNode);
}


void CNode::InternalSetElementValue(const tstring& sValue)
{
	m_pDOMNode->appendChild(m_pDOMNode->getOwnerDocument()->createTextNode(X(sValue)));
}


bool CNode::InternalNamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName)
{
	tstring sNodeURI;
	tstring sNodeName;
	if (pNode->getNamespaceURI())
		sNodeURI = XC2TS(pNode->getNamespaceURI());
	if (pNode->getLocalName())
		sNodeName = XC2TS(pNode->getLocalName());
	return sNamespaceURI == sNodeURI && sName == sNodeName;
}

bool CNode::NamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName)
{
	return InternalNamesMatch(pNode, sNamespaceURI, sName);
}

int CNode::ChildCountInternal(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	if (eNodeType == Element)
	{
		int nCount = 0;

		for (xercesc::DOMNode* pNode = m_pDOMNode->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
			if (InternalNamesMatch(pNode, sNamespaceURI, sName))
				nCount++;

		return nCount;
	}
	else
		return (static_cast<xercesc::DOMElement*>(m_pDOMNode))->hasAttributeNS(X(sNamespaceURI), Q2L(X(sName))) ? 1 : 0;
}


bool CNode::InternalHasChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	if (eNodeType == Element)
	{
		for (xercesc::DOMNode* pNode = m_pDOMNode->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
			if (InternalNamesMatch(pNode, sNamespaceURI, sName))
				return true;

		return false;
	}
	else
		return (static_cast<xercesc::DOMElement*>(m_pDOMNode))->hasAttributeNS(X(sNamespaceURI), Q2L(X(sName)));
}


xercesc::DOMNode* CNode::InternalCreate(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue)
{
	switch ( eNodeType )
	{
		case Element:
			{
			xercesc::DOMElement* pElement = m_pDOMNode->getOwnerDocument()->createElementNS(X(sNamespaceURI), X(sName));
			pElement->appendChild(m_pDOMNode->getOwnerDocument()->createTextNode(X(sValue)));
			return pElement;
			}
		case Text:
			{
			xercesc::DOMText* pText = m_pDOMNode->getOwnerDocument()->createTextNode(X(sValue));
			return pText;
			}
		case CData:
			{
			xercesc::DOMCDATASection* pText = m_pDOMNode->getOwnerDocument()->createCDATASection(X(sValue));
			return pText;
			}
		case ProcessingInstruction:
			{
			xercesc::DOMProcessingInstruction* pText = m_pDOMNode->getOwnerDocument()->createProcessingInstruction(X(sName), X(sValue));
			return pText;
			}
		case Comment:
			{
			xercesc::DOMComment* pText = m_pDOMNode->getOwnerDocument()->createComment(X(sValue));
			return pText;
			}
		default: //attribute
			{
			xercesc::DOMAttr* pAttribute = m_pDOMNode->getOwnerDocument()->createAttributeNS(X(sNamespaceURI), X(sName));
			pAttribute->setNodeValue(X(sValue));
			return pAttribute;
			}
	}
}


xercesc::DOMNode* CNode::InternalAppend(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue)
{
	switch ( eNodeType )
	{
		case Element:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, sNamespaceURI, sName, sValue));
		case Text:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), _T(""), sValue));
		case CData:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), _T(""), sValue));
		case ProcessingInstruction:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), sName, sValue));
		case Comment:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), _T(""), sValue));
		default:
			return m_pDOMNode->getAttributes()->setNamedItemNS(InternalCreate(eNodeType, sNamespaceURI, sName, sValue));
	}
}


xercesc::DOMNode* CNode::InternalAppendNode(const tstring& sNamespaceURI, const tstring& sName, CNode& rNode)
{
	xercesc::DOMNode* pOldNode = rNode.m_pDOMNode;
	rNode.m_pDOMNode = m_pDOMNode->appendChild(InternalAdopt(rNode.m_pDOMNode, sNamespaceURI, sName));
	return rNode.m_pDOMNode;
}


xercesc::DOMNode* CNode::InternalGetAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex)
{
	if (eNodeType == Element)
	{
		int nCount = 0;

		for (xercesc::DOMNode* pNode = m_pDOMNode->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
			if (InternalNamesMatch(pNode, sNamespaceURI, sName))
				if (nCount++ == nIndex)
					return pNode;

		throw CXmlException(1, _T("Index out of range"));
	}
	else
	{
		xercesc::DOMAttr* pAttr = static_cast<xercesc::DOMAttr*>(m_pDOMNode->getAttributes()->getNamedItemNS(X(sNamespaceURI), Q2L(X(sName))));
		if (pAttr != NULL)
			return pAttr;
		else
			throw CXmlException(1, _T("Index out of range"));
	}
}

xercesc::DOMNode* CNode::InternalGetFirstChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	if (eNodeType == Element)
	{
		for (xercesc::DOMNode* spChild = m_pDOMNode->getFirstChild(); spChild != NULL; spChild = spChild->getNextSibling())
			if (InternalNamesMatch(spChild, sNamespaceURI, sName))
					return spChild;
	}
	else // eNodeType == Attribute
	{
		xercesc::DOMAttr* pAttr = static_cast<xercesc::DOMAttr*>(m_pDOMNode->getAttributes()->getNamedItemNS(X(sNamespaceURI), Q2L(X(sName))));
		if (pAttr != NULL)
			return pAttr;
	}
	return NULL;
}

xercesc::DOMNode* CNode::InternalGetNextChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, xercesc::DOMNode* pCurNode )
{
	if (eNodeType == Element && pCurNode != NULL)
	{
		for (xercesc::DOMNode* spChild = pCurNode->getNextSibling(); spChild != NULL; spChild = spChild->getNextSibling())
			if (InternalNamesMatch(spChild, sNamespaceURI, sName))
					return spChild;
	}

	return NULL;
}


xercesc::DOMNode* CNode::InternalGet(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	return InternalGetAt(eNodeType, sNamespaceURI, sName, 0);
}


xercesc::DOMNode* CNode::InternalInsertAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue)
{
	if (eNodeType == Element)
		return m_pDOMNode->insertBefore(
				InternalCreate(eNodeType, sNamespaceURI, sName, sValue),
				InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex)
				);
	else
		return InternalAppend(eNodeType, sNamespaceURI, sName, sValue);
}


xercesc::DOMNode* CNode::InternalInsertNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode)
{
	rNode.m_pDOMNode = m_pDOMNode->insertBefore(
			InternalAdopt(rNode.m_pDOMNode, sNamespaceURI, sName),
			InternalGetAt(Element, sNamespaceURI, sName, nIndex)
			);

	return rNode.m_pDOMNode;
}


xercesc::DOMNode* CNode::InternalReplaceAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue)
{
	if (eNodeType == Element)
		return m_pDOMNode->replaceChild(
				InternalCreate(eNodeType, sNamespaceURI, sName, sValue),
				InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex)
				);
	else
		return InternalAppend(eNodeType, sNamespaceURI, sName, sValue);
}


xercesc::DOMNode* CNode::InternalReplaceNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode)
{
	xercesc::DOMNode* pOldNode = rNode.m_pDOMNode;
	rNode.m_pDOMNode = m_pDOMNode->replaceChild(
			InternalAdopt(rNode.m_pDOMNode, sNamespaceURI, sName),
			InternalGetAt(Element, sNamespaceURI, sName, nIndex)
			);
	CDoc::ReleaseFragment(pOldNode);

	return rNode.m_pDOMNode;
}


xercesc::DOMNode* CNode::InternalRemoveAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex)
{
	if (eNodeType == Element)
		return m_pDOMNode->removeChild(InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex));
	else
		return m_pDOMNode->getAttributes()->removeNamedItemNS(X(sNamespaceURI), Q2L(X(sName)));
}


xercesc::DOMElement* CNode::InternalAdopt(xercesc::DOMNode* pElement, const tstring& sNamespaceURI, const tstring& sName)
{
	xercesc::DOMDocument* pDoc = m_pDOMNode->getOwnerDocument();
	xercesc::DOMElement* pNewElement = pDoc->createElementNS(X(sNamespaceURI), X(sName));

	for (xercesc::DOMNode* pNode = pElement->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
	{
		pNewElement->appendChild(pDoc->importNode(pNode, true));
	}

	xercesc::DOMNamedNodeMap* pSrcAttributes = pElement->getAttributes();
	xercesc::DOMNamedNodeMap* pDstAttributes = pNewElement->getAttributes();
	for (XMLSize_t i = 0; i < pSrcAttributes->getLength(); i++)
	{
		xercesc::DOMNode* pNode = pSrcAttributes->item(i);
		pDstAttributes->setNamedItemNS(pDoc->importNode(pNode, true));
	}

	return pNewElement;

}


void CNode::DeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI)
{
	if (sURI.empty())
		return;

	xercesc::DOMNamedNodeMap* pAttrs = pElement->getAttributes();
	for (XMLSize_t i = 0; i < pAttrs->getLength(); i++)
	{
		xercesc::DOMAttr* pAttr = static_cast<xercesc::DOMAttr*>(pAttrs->item(i));
		if (xercesc::XMLString::startsWith(pAttr->getNodeName(), (XMLCh*)L"xmlns") && xercesc::XMLString::equals(pAttr->getValue(), X(sURI)))
			return;
	}

	if (sPrefix == _T("xml") && sURI == _T("http://www.w3.org/XML/1998/namespace"))
		return;


	InternalDeclareNamespace(pElement, sPrefix, sURI);
}


void CNode::InternalDeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI)
{
	tstring sTmp;

	if (sPrefix.empty())
		sTmp = _T("xmlns");
	else
		sTmp = _T("xmlns:") + sPrefix;

	pElement->setAttributeNS(X("http://www.w3.org/2000/xmlns/"), X(sTmp), X(sURI));
}


const XMLCh* CNode::LookupPrefix(xercesc::DOMNode* pNode, const XMLCh* szURI)
{
	if (pNode == NULL)
		return NULL;

	if (szURI == NULL || *szURI == 0)
		return NULL;

	if (pNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
		xercesc::DOMNamedNodeMap* pAttrs = pNode->getAttributes();
		if (pAttrs != NULL)
		{
			XMLSize_t len = pAttrs->getLength();
			for (XMLSize_t i = 0; i < len; i++)
			{
				xercesc::DOMAttr* pAttr = static_cast<xercesc::DOMAttr*>(pAttrs->item(i));
				const XMLCh* szName = pAttr->getName();
				const XMLCh* szValue = pAttr->getValue();
				if (xercesc::XMLString::equals(szValue, szURI))
				{
					if (xercesc::XMLString::stringLen(szName) < 6 || !xercesc::XMLString::startsWith(szName, (XMLCh*)L"xmlns"))
						continue;
					else
						return szName + 6;
				}
			}
		}
		return LookupPrefix(pNode->getParentNode(), szURI);
	}
	else if (pNode->getNodeType() == xercesc::DOMNode::ATTRIBUTE_NODE)
	{
		return LookupPrefix(static_cast<xercesc::DOMAttr*>(pNode)->getOwnerElement(), szURI);
	}
	else
	{
		return NULL;
	}
}

void CNode::InternalSetAttribute( const tstring& sName, const tstring& sNamespaceURI, const tstring& sValue)
{
	tstring sQName = _T("xsi:") + sName;
	xercesc::DOMElement* pElement = static_cast<xercesc::DOMElement*>(m_pDOMNode);
	pElement->setAttribute(X(sQName), X(sValue));
}

xercesc::DOMNode* CNode::LookupDefaultNamespace(xercesc::DOMNode* pDOMNode)
{
	if (pDOMNode == NULL)
		return NULL;

	if (pDOMNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
		xercesc::DOMElement* pElement = static_cast<xercesc::DOMElement*>(pDOMNode);
		xercesc::DOMAttr* pAttr = pElement->getAttributeNodeNS(X("http://www.w3.org/2000/xmlns/"), X("xmlns"));
		if (pAttr != NULL)
			return pAttr;
	}

	return LookupDefaultNamespace(pDOMNode->getParentNode());
}


void CNode::InternalAdjustPrefix(xercesc::DOMNode* pDOMNode, bool bQualified)
{
	if (pDOMNode == NULL)
		return;
	if (bQualified)
	{
		const XMLCh* szPrefix = LookupPrefix(pDOMNode, pDOMNode->getNamespaceURI());
		if (szPrefix)
			pDOMNode->setPrefix(szPrefix);
	}
	else if (pDOMNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
		xercesc::DOMElement* pElement = static_cast<xercesc::DOMElement*>(pDOMNode);
		if (LookupDefaultNamespace(pElement) != NULL)
			InternalDeclareNamespace(pElement, _T(""), _T(""));
	}
}



CAnyTypeNode::CAnyTypeNode(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
}

CAnyTypeNode& CAnyTypeNode::operator=(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
	return *this;
}

void CAnyTypeNode::Assign(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
}

CAnyTypeNode::operator CSchemaString()
{
	return InternalGetElementValue();
}

CNode::EGroupType CAnyTypeNode::GetGroupType()
{
	return eSequence;
}

void CAnyTypeNode::AdjustPrefix()
{
}

void CAnyTypeNode::AddTextNode(CSchemaString text)
{
	InternalAppend(Text, _T(""), _T("#text"), text);
}

void CAnyTypeNode::AddCDataNode(CSchemaString text)
{
	InternalAppend(CData, _T(""), _T("#cdata"), text);
}

void CAnyTypeNode::AddComment(CSchemaString text)
{
	InternalAppend(Comment, _T(""), _T("#cdata"), text);
}

void CAnyTypeNode::AddProcessingInstruction(CSchemaString name, CSchemaString text)
{
	InternalAppend(ProcessingInstruction, _T(""), name, text);
}



} // namespace altova
